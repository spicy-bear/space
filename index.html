<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starbase Survivor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #111827;
            color: #F3F4F6;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        #game-container {
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            background-color: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(251, 146, 60, 0.4);
            position: relative;
            cursor: crosshair;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            image-rendering: pixelated;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            background-color: rgba(17, 24, 39, 0.9);
            border-radius: 8px;
            transition: opacity 0.3s ease-in-out;
            padding: 2rem;
            box-sizing: border-box;
            z-index: 10; /* Ensure overlay is on top */
        }
        .overlay-hidden {
            opacity: 0;
            pointer-events: none;
        }
        .game-button {
            background-color: #FB923C;
            color: #111827;
            padding: 1rem 2rem; border-radius: 8px;
            text-transform: uppercase; font-size: 1.25rem; cursor: pointer;
            border: 2px solid #FDBA74;
            box-shadow: 0 4px #C2410C;
            transition: all 0.1s ease-in-out;
        }
        .game-button:hover:not(:disabled) {
            background-color: #FDBA74; transform: translateY(-2px); box-shadow: 0 6px #C2410C;
        }
        .game-button:active:not(:disabled) {
            transform: translateY(2px); box-shadow: 0 2px #C2410C;
        }
        .game-button:disabled {
            background-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
            box-shadow: none;
        }
        .map-card {
            background-color: #374151; border: 2px solid #9CA3AF; border-radius: 8px;
            padding: 1rem; margin-bottom: 1rem; width: 40%; text-align: left; cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .map-card:hover {
            transform: translateY(-5px); border-color: #FB923C; background-color: #4B5563;
        }
        .map-card h3 { color: #FDBA74; }
        .upgrade-card {
            background-color: #374151; border: 2px solid #9CA3AF; border-radius: 8px;
            padding: 1rem; margin: 0 1rem; width: 28%; cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .upgrade-card:hover { transform: translateY(-5px); border-color: #FB923C; background-color: #4B5563; }
        .card-title { font-size: 1.1rem; color: #FB923C; margin-bottom: 0.75rem;}
        .card-desc { font-size: 0.8rem; color: #D1D5DB; }
        #hud-materials {
            position: absolute; bottom: 30px; right: 10px;
            background-color: rgba(17,24,39,0.7); padding: 8px; border-radius: 5px;
            font-size: 10px; text-align: right; line-height: 1.5;
            z-index: 5; /* Below overlays, above canvas */
        }
        /* Station Menu */
        .station-menu-content { width: 90%; max-width: 800px; }
        /* Removed max-height and overflow-y from .upgrade-tree */
        .upgrade-tree { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            width: 100%; 
            padding-right: 1rem; 
        }
        .upgrade-node { 
            display: flex; 
            align-items: center; 
            margin-bottom: 1.5rem; 
            width: 100%; 
            background-color: #1f2937; 
            padding: 1rem; 
            border-radius: 8px; 
            border: 2px solid #374151; 
        }
        .upgrade-icon { 
            width: 64px; height: 64px; 
            border: 2px solid #6b7280; 
            background-color: #1f2937; 
            border-radius: 8px; 
            margin-right: 1.5rem; 
            flex-shrink: 0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 32px;
        }
        .upgrade-icon.can-afford { border-color: #a3e635; }
        .upgrade-icon.is-max { border-color: #f97316; }
        .upgrade-details { text-align: left; flex-grow: 1; }
        .upgrade-cost { font-size: 0.7rem; color: #fca5a5; margin-top: 0.5rem; }

        /* New styles for icon-based upgrade selection */
        #upgradeIconsContainer {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem; /* Space between icons */
            width: 100%;
            max-width: 800px; /* Adjust as needed */
            margin-bottom: 2rem;
        }
        .upgrade-icon-button {
            background-color: #374151;
            border: 2px solid #6b7280;
            border-radius: 8px;
            padding: 1rem;
            width: 120px; /* Fixed width for icons */
            height: 120px; /* Fixed height for icons */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 40px; /* Icon size */
            line-height: 1.2;
            color: #FDBA74; /* Icon color */
        }
        .upgrade-icon-button:hover {
            transform: translateY(-5px);
            border-color: #FB923C;
            background-color: #4B5563;
        }
        .upgrade-icon-button.selected {
            border-color: #4ade80; /* Highlight color for selected icon */
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.5);
        }
        .upgrade-icon-button .icon-text {
            font-size: 0.75rem; /* Smaller text for icon label */
            margin-top: 0.5rem;
            color: #D1D5DB;
            text-transform: uppercase;
        }

        #upgradeDetailsBox {
            background-color: #1f2937;
            padding: 1.5rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            width: 90%;
            max-width: 600px;
            text-align: left;
            margin-top: 1rem;
            box-shadow: 0 0 10px rgba(251, 146, 60, 0.2);
            /* Hidden by default, shown by JS */
            display: none; 
            flex-direction: column;
            justify-content: space-between;
        }
        #upgradeDetailsBox h3 {
            font-size: 1.5rem;
            color: #FB923C;
            margin-bottom: 0.5rem;
        }
        #upgradeDetailsBox p {
            font-size: 0.9rem;
            color: #D1D5DB;
            margin-bottom: 0.5rem;
        }
        #upgradeDetailsBox .cost-text {
            color: #fca5a5;
            font-size: 0.8rem;
            margin-top: 0.75rem;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="mapSelection" class="overlay overlay-hidden"></div>
        <div id="levelUpSelection" class="overlay overlay-hidden"></div>
        <div id="stationMenu" class="overlay overlay-hidden">
            <h1 class="text-4xl mb-8 text-orange-300" id="stationMenuTitle"></h1>
            <div id="upgradeIconsContainer" class="flex flex-wrap justify-center gap-4 mb-8">
                <!-- Upgrade icons will be dynamically loaded here -->
            </div>
            <div id="upgradeDetailsBox" class="hidden">
                <h3 id="detailTitle"></h3>
                <p id="detailDesc"></p>
                <p id="detailLevel"></p>
                <p class="cost-text" id="detailCost"></p>
                <button id="detailBuyButton" onclick="" class="game-button mt-4 w-full"></button>
            </div>
            <button onclick="window.closeStationMenu()" class="game-button mt-8 text-sm px-6 py-3">Return to Starbase</button>
        </div>
        <div id="gameOver" class="overlay overlay-hidden"></div>
        <div id="victory" class="overlay overlay-hidden"></div>
        <div id="hud-materials"></div>
    </div>

    <script>
    (function() {
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        // --- Game State Variables ---
        let gameState = 'starbase_hub';
        let gameLoopId;
        let lastTime = 0;
        let globalAnimTimer = 0;
        const mouse = { x: 0, y: 0, facingRight: true, click: false, prevClick: false };
        let activeMap = null;
        let activeStation = null; // Stores 'workshop' or 'armory'
        let selectedUpgradeId = null; // Track currently selected upgrade in menu
        
        // --- Entity & Data Arrays ---
        const player = {};
        const playerProjectiles = [];
        const enemyProjectiles = [];
        const enemies = [];
        const shards = [];
        const materialDrops = [];
        const terrain = [];
        const baseScenery = [];
        const gameDuration = 120;
        let timer = gameDuration;
        let waveConfig = {};
        const keys = { w: false, a: false, s: false, d: false, ' ': false, e: false };
        let interactionTarget = null;

        // --- Data Definitions ---
        const starbaseHub = {
            rect: {x: 0, y: 0, width: 0, height: 0},
            terminal: { x: 0, y: 0, width: 80, height: 70, id: 'deploy', name: 'Deployment Terminal' },
            workshop: { x: 0, y: 0, width: 90, height: 60, id: 'workshop', name: 'Workshop' },
            armory: { x: 0, y: 0, width: 60, height: 80, id: 'armory', name: 'Armory' },
            database: { x: 0, y: 0, width: 70, height: 70, id: 'database', name: 'Database' },
            table: { x: 0, y: 0 },
            bed: { x: 0, y: 0, width: 120, height: 70, id: 'bed', name: 'Bed' },
            kitchen: { x: 0, y: 0, width: 80, height: 70, id: 'kitchen', name: 'Galley' },
            interactionRadius: 60,
            interactables: [],
        };
        const maps = [
            { id: 'planet_v2', name: 'Planet V-II', description: 'A desolate rock with a mix of fauna. Standard resource distribution.', resources: ['moondust', 'alien_chitin'] },
            { id: 'cratered_moon', name: 'Cratered Moon', description: 'Low gravity, high risk. Craters block sight and movement. Rich in moondust.', resources: ['moondust'] },
            { id: 'verdant_prime', name: 'Verdant Prime', description: 'Lush and overgrown. Flora can provide cover. Rich in organic matter.', resources: ['plant_fiber', 'alien_chitin'] },
        ];
        const powerUps = [
            { id: 'atk_power', title: 'Power Shot', desc: '+10% Attack Damage', apply: p => { p.attackPower *= 1.1; } },
            { id: 'atk_speed', title: 'Rapid Fire', desc: '+15% Fire Rate', apply: p => { p.fireRate *= 1.15; } },
            { id: 'proj_speed', title: 'Hyper-Velocity', desc: '+20% Projectile Speed', apply: p => { p.projectileSpeed *= 1.2; } },
            { id: 'max_hp', title: 'Titanium Hull', desc: '+25 Max Health', apply: p => { p.maxHealth += 25; p.health += 25; } },
            { id: 'hp_regen', title: 'Nano-Repair', desc: 'Regen 1 HP/sec', apply: p => { p.healthRegen += 1; } },
            { id: 'move_speed', title: 'Servo-Grease', desc: '+10% Move Speed', apply: p => { p.speed *= 1.1; } },
            { id: 'stamina_regen', title: 'Adrenal Pump', desc: '+20% Stamina Regen', apply: p => { p.staminaRegen *= 1.2; } },
            { id: 'xp_gain', title: 'Shard Magnet', desc: '+15% XP Gain', apply: p => { p.xpGainMultiplier *= 1.15; } },
        ];
        const materials = {
            moondust: { color: '#E5E7EB', name: 'Moondust' },
            alien_chitin: { color: '#FCA5A5', name: 'Alien Chitin' },
            plant_fiber: { color: '#86EFAC', name: 'Plant Fiber' },
        };
        const permanentUpgrades = {
            workshop: [
                { id: 'suit_hp', name: 'Reinforce Hull', desc: '+10 Max Health', maxLevel: 10, cost: (l) => ({ moondust: 10 * (l + 1) }), icon: '❤️' },
                { id: 'suit_regen', name: 'Nano-bots', desc: '+0.1 HP/sec', maxLevel: 5, cost: (l) => ({ moondust: 20 * (l + 1), plant_fiber: 5 * (l + 1)}), icon: '➕' },
                { id: 'suit_stamina', name: 'Capacitors', desc: '+10 Max Stamina', maxLevel: 5, cost: (l) => ({ moondust: 15 * (l + 1) }), icon: '⚡' },
            ],
            armory: [
                { id: 'gun_dmg', name: 'Calibrate Blaster', desc: '+1 Base Damage', maxLevel: 10, cost: (l) => ({ moondust: 10 * (l + 1), alien_chitin: 5 * (l+1) }), icon: '🎯' },
                { id: 'gun_rate', name: 'Tune Firing Pin', desc: '+5% Fire Rate', maxLevel: 5, cost: (l) => ({ alien_chitin: 10 * (l+1) }), icon: '🔥' },
                { id: 'gun_proj_speed', name: 'Velocity Enhancer', desc: '+10 Projectile Speed', maxLevel: 5, cost: (l) => ({ moondust: 10 * (l + 1), alien_chitin: 5 * (l+1) }), icon: '🚀' }
            ]
        };
        const textures = {};
        const sprites = {
            drawPlayer: (ctx, x, y, frame, facingRight) => {
                const p = 3;
                ctx.save(); ctx.translate(x, y); if (!facingRight) ctx.scale(-1, 1);
                ctx.fillStyle = '#9ca3af'; ctx.fillRect(-2*p, -3*p, 4*p, 4*p); // Body
                ctx.fillStyle = '#d1d5db'; ctx.fillRect(-1.5*p, -3*p, 3*p, 3*p); // Torso highlight
                const legOffset = (frame === 1) ? p : 0;
                ctx.fillStyle = '#6b7280'; ctx.fillRect(-2*p, 1*p, 2*p, 3*p); // Left leg
                ctx.fillStyle = '#6b7280'; ctx.fillRect(legOffset, 1*p, 2*p, 3*p); // Right leg
                ctx.fillStyle = '#c2410c'; ctx.fillRect(-2.5*p, -7*p, 5*p, 5*p); // Helmet base
                ctx.fillStyle = '#f97316'; ctx.fillRect(-2*p, -6.5*p, 4*p, 4*p); // Helmet visor
                ctx.fillStyle = '#111827'; ctx.fillRect(-1.5*p, -6*p, 4*p, 3*p); // Visor darker part
                ctx.fillStyle = '#6b7280'; ctx.fillRect(1*p, -2*p, 3*p, 1*p); // Arm
                ctx.fillStyle = '#4b5563'; ctx.fillRect(2*p, -3*p, 1*p, 2*p); // Blaster
                ctx.restore();
            },
            drawCharger: (ctx, x, y) => { const p = 4; ctx.save(); ctx.translate(x, y); ctx.fillStyle = '#7f1d1d'; ctx.fillRect(-2*p, -1*p, 4*p, 3*p); ctx.fillStyle = '#BE123C'; ctx.fillRect(-1.5*p, -1.5*p, 3*p, 2*p); ctx.fillStyle = '#FCA5A5'; ctx.fillRect(-1*p, -2*p, 2*p, 1*p); ctx.fillStyle = '#991b1b'; ctx.fillRect(-2.5*p, 0*p, 1*p, 2*p); ctx.fillStyle = '#991b1b'; ctx.fillRect(1.5*p, 0*p, 1*p, 2*p); ctx.restore(); },
            drawSpitter: (ctx, x, y) => { const p = 3; ctx.save(); ctx.translate(x, y); ctx.fillStyle = '#5b21b6'; ctx.fillRect(-1.5*p, -2.5*p, 3*p, 5*p); ctx.fillStyle = '#8B5CF6'; ctx.fillRect(-1*p, -2*p, 2*p, 4*p); ctx.fillStyle = '#C4B5FD'; ctx.fillRect(-0.5*p, -3.5*p, 1*p, 1*p); ctx.fillStyle = '#7c3aed'; ctx.fillRect(-2.5*p, -1.5*p, 1*p, 3*p); ctx.fillStyle = '#7c3aed'; ctx.fillRect(1.5*p, -1.5*p, 1*p, 3*p); ctx.restore(); },
            drawTerminal: (ctx, x, y, width, height, animTimer) => { ctx.fillStyle = '#1e293b'; ctx.fillRect(x - width/2, y - height/2, width, height); ctx.fillStyle = '#0f172a'; ctx.fillRect(x - width/2 + 5, y - height/2 + 5, width - 10, height-10); const scanLineY = (y - height/2 + 10) + ((animTimer * 20) % (height*0.5)); ctx.fillStyle = '#f97316'; ctx.fillRect(x - width/2 + 10, scanLineY, width - 20, 2); ctx.fillStyle = '#334155'; ctx.fillRect(x - width/2 + 10, y - height/2 + height*0.7, width-20, height*0.2); },
            drawWorkshop: (ctx, x, y, width, height) => { ctx.fillStyle = '#4b5563'; ctx.fillRect(x - width/2, y-height/2, width, height); ctx.fillStyle = '#1e293b'; ctx.fillRect(x - width/2+5, y-height/2+5, width-10, height-10); ctx.fillStyle = '#f97316'; ctx.fillRect(x - width/2+10, y-height/2+10, 5, 5); ctx.fillStyle = '#9ca3af'; ctx.fillRect(x - width/2+20, y-height/2+20, 20, 5); ctx.fillRect(x - width/2+45, y-height/2+30, 5, 15); },
            drawArmory: (ctx, x, y, width, height) => { ctx.fillStyle = '#334155'; ctx.fillRect(x-width/2, y-height/2, width, height); ctx.fillStyle = '#1e293b'; ctx.fillRect(x-width/2 + 5, y-height/2, width-10, height-5); ctx.fillStyle = '#f97316'; ctx.fillRect(x-width/2 + 10, y-height/2 + 10, width-20, 5); ctx.fillRect(x-width/2 + 10, y-height/2 + 20, width-20, 5); },
            drawBed: (ctx, x, y, width, height) => { ctx.fillStyle = '#334155'; ctx.fillRect(x-width/2, y-height/2, width, height); ctx.fillStyle = '#1e293b'; ctx.fillRect(x-width/2+5, y-height/2+5, width-10, height-10); ctx.fillStyle = '#c2410c'; ctx.fillRect(x-width/2+10, y-height/2+10, width-20, height-25); ctx.fillStyle = '#f97316'; ctx.fillRect(x-width/2+15, y-height/2+15, 20, 10); },
            drawKitchen: (ctx, x, y, width, height) => { ctx.fillStyle = '#4b5563'; ctx.fillRect(x-width/2, y-height/2, width, height); ctx.fillStyle = '#1e293b'; ctx.fillRect(x-width/2+5, y-height/2+5, width-10, height-10); ctx.fillStyle = '#0f172a'; ctx.fillRect(x-width/2+10, y-height/2+10, width-20, 20); ctx.fillStyle = '#f97316'; ctx.fillRect(x-width/2+15, y-height/2+15, 5, 5); },
            drawTableAndChairs: (ctx, x, y) => { ctx.fillStyle = '#78350f'; ctx.fillRect(x - 30, y - 15, 60, 30); ctx.fillStyle = '#9ca3af'; ctx.fillRect(x - 25, y - 10, 50, 20); ctx.fillStyle = '#374151'; ctx.fillRect(x-50, y-10, 15, 20); ctx.fillStyle = '#111827'; ctx.fillRect(x-48, y-8, 11, 16); ctx.fillStyle = '#374151'; ctx.fillRect(x+35, y-10, 15, 20); ctx.fillStyle = '#111827'; ctx.fillRect(x+37, y-8, 11, 16); },
            // New drawing function for Database
            drawDatabase: (ctx, x, y, width, height) => {
                ctx.fillStyle = '#607d8b'; // Dark blue-gray for the database unit
                ctx.fillRect(x - width / 2, y - height / 2, width, height);
                ctx.fillStyle = '#37474f'; // Darker screen/panel
                ctx.fillRect(x - width / 2 + 5, y - height / 2 + 5, width - 10, height - 10);
                ctx.fillStyle = '#4fc3f7'; // Light blue data lines
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(x - width / 2 + 10, y - height / 2 + 15 + i * 15, width - 20, 2);
                }
            },
            drawStarbase: (ctx, width, height, animTimer) => { ctx.fillStyle = textures.cratered_moon; ctx.fillRect(0, 0, width, height); baseScenery.forEach(r => sprites.drawRock(ctx, r.x, r.y, r.subType)); const room = starbaseHub.rect; ctx.fillStyle = textures.starbase_floor; ctx.fillRect(room.x, room.y, room.width, room.height); ctx.strokeStyle = '#475569'; ctx.lineWidth = 10; ctx.strokeRect(room.x, room.y, room.width, room.height); ctx.fillStyle = '#0f172a'; for(let i=room.x; i < room.x + room.width; i += 80) { ctx.fillRect(i, room.y - 10, 20, 10); ctx.fillRect(i+30, room.y + room.height, 20, 10); } },
            drawPlanetFloor: (ctx, width, height) => { if (activeMap) ctx.fillStyle = textures[activeMap.id]; else ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height);},
            drawRock: (ctx, x, y, subType) => { ctx.fillStyle = '#52525b'; ctx.beginPath(); if(subType === 1) { ctx.moveTo(x, y); ctx.lineTo(x + 20, y - 10); ctx.lineTo(x + 30, y + 15); ctx.lineTo(x + 10, y + 25); ctx.lineTo(x - 15, y + 10); } else { ctx.moveTo(x, y); ctx.lineTo(x + 15, y - 15); ctx.lineTo(x + 25, y + 5); ctx.lineTo(x - 5, y + 20); } ctx.closePath(); ctx.fill(); ctx.fillStyle = '#a1a1aa'; ctx.beginPath(); if(subType === 1) { ctx.moveTo(x, y); ctx.lineTo(x + 20, y-10); ctx.lineTo(x-5, y-5); } else { ctx.moveTo(x, y); ctx.lineTo(x+15, y-15); ctx.lineTo(x+5, y-5); } ctx.closePath(); ctx.fill(); },
            drawPlant: (ctx, x, y, subType) => { ctx.fillStyle = subType === 1 ? '#166534' : '#15803d'; ctx.strokeStyle = '#14532d'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x, y); if (subType < 3) { ctx.lineTo(x, y - 20); ctx.stroke(); ctx.fillStyle = subType === 1 ? '#4ade80' : '#86efac'; ctx.beginPath(); ctx.arc(x, y - 25, 10, 0, Math.PI * 2); ctx.fill(); } else { ctx.bezierCurveTo(x-10, y-15, x+10, y-25, x, y-30); ctx.stroke(); ctx.fillStyle = subType === 3 ? '#22c55e' : '#10b981'; ctx.beginPath(); ctx.fillRect(x-4, y-35, 8, 8); } },
            drawShrub: (ctx, x, y) => { ctx.fillStyle = '#4d7c0f'; ctx.beginPath(); ctx.arc(x, y, 8, Math.PI, 0); ctx.fill(); ctx.fillStyle = '#a3e635'; ctx.beginPath(); ctx.arc(x-4, y, 4, Math.PI, 0); ctx.arc(x+4, y, 4, Math.PI, 0); ctx.fill(); },
            drawResourceNode: (ctx, node) => { ctx.fillStyle = materials[node.material].color; ctx.beginPath(); ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2); ctx.fill(); const hp = node.health / node.maxHealth; if(hp < 1){ ctx.fillStyle = '#4B5563'; ctx.fillRect(node.x - node.radius, node.y - node.radius - 8, node.radius * 2, 4); ctx.fillStyle = '#FBBF24'; ctx.fillRect(node.x - node.radius, node.y - node.radius - 8, node.radius * 2 * hp, 4); } },
            drawMaterial: (ctx, x, y, type) => { ctx.fillStyle = materials[type].color; ctx.fillRect(x-5, y-5, 10, 10); ctx.strokeStyle = '#111827'; ctx.lineWidth = 2; ctx.strokeRect(x-5, y-5, 10, 10); },
        };
        
        function setCanvasDimensions() {
            const rect = document.getElementById('game-container').getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            starbaseHub.rect = { x: canvas.width*0.25, y: canvas.height*0.1, width: canvas.width*0.5, height: canvas.height*0.8 };
            const room = starbaseHub.rect;
            // Set position for the terminal
            starbaseHub.terminal.x = room.x + room.width / 2; starbaseHub.terminal.y = room.y + 50; 
            starbaseHub.armory.x = room.x + room.width - 50; starbaseHub.armory.y = room.y + room.height / 2 + 20;
            starbaseHub.workshop.x = room.x + 60; starbaseHub.workshop.y = room.y + room.height / 2 + 20;
            starbaseHub.database.x = room.x + room.width / 2; starbaseHub.database.y = room.y + room.height - 50;
            starbaseHub.table.x = room.x + 80; starbaseHub.table.y = room.y + room.height - 50;
            starbaseHub.bed.x = room.x + 70; starbaseHub.bed.y = room.y + 50;
            starbaseHub.kitchen.x = room.x + room.width - 80; starbaseHub.kitchen.y = room.y + 50;
            // Re-added terminal to the interactables list
            starbaseHub.interactables = [starbaseHub.terminal, starbaseHub.workshop, starbaseHub.armory, starbaseHub.database, starbaseHub.bed, starbaseHub.kitchen];
            baseScenery.length = 0;
            for(let i=0; i < 20; i++) baseScenery.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, subType: Math.ceil(Math.random()*2) });
        }

        function createTextures() { 
            // Helper function to create a textured pattern
            function createPattern(baseColor, detailColors, detailCount = 30, detailSize = 2) { 
                const tex = document.createElement('canvas'); 
                tex.width = 64; tex.height = 64; 
                const texCtx = tex.getContext('2d'); 
                texCtx.fillStyle = baseColor; texCtx.fillRect(0,0,64,64); 
                for(let i=0; i<detailCount; i++) { 
                    texCtx.fillStyle = detailColors[Math.floor(Math.random() * detailColors.length)]; 
                    texCtx.fillRect(Math.random()*64, Math.random()*64, detailSize, detailSize); 
                } 
                return ctx.createPattern(tex, 'repeat'); 
            } 
            textures.starbase_floor = createPattern('#1e293b', ['#334155', '#475569'], 20, 4); 
            textures.planet_v2 = createPattern('#2d232e', ['#3d303f', '#1e1a1f'], 50); 
            textures.cratered_moon = createPattern('#47475a', ['#5c5c70', '#3e3e4d'], 50); 
            textures.verdant_prime = createPattern('#2a3d34', ['#3a5447', '#1f2e26'], 50); 
        };
        
        // Function to show/hide and populate overlay elements
        function showOverlay(overlayId, content) {
            document.querySelectorAll('.overlay').forEach(o => o.classList.add('overlay-hidden')); // Hide all
            const el = document.getElementById(overlayId);
            if(el) {
                if(content) el.innerHTML = content; // Set content if provided
                el.classList.remove('overlay-hidden'); // Show target overlay
            }
        }
        
        function handleInteraction(id) {
            if (id === 'deploy') { showMapSelection(); }
            else if (id === 'workshop' || id === 'armory') { openStationMenu(id); }
            else { console.log(`Interacted with ${id}`); }
        }
        
        // Global functions for HTML buttons
        window.returnToHub = () => { 
            if (gameLoopId) cancelAnimationFrame(gameLoopId); 
            gameState = 'starbase_hub'; 
            setupStarbaseHub(); 
            showOverlay(null); // Hide all overlays
            lastTime = performance.now(); 
            gameLoopId = requestAnimationFrame(gameLoop); 
        };
        window.startGame = (mapId) => { 
            activeMap = maps.find(m => m.id === mapId); 
            resetForMission(); 
            gameState = 'playing'; 
            showOverlay(null); // Hide all overlays
        };

        // Player setup and permanent upgrades
        function setupStarbaseHub() { player.x = canvas.width / 2; player.y = starbaseHub.rect.y + starbaseHub.rect.height - 50; player.stamina = player.maxStamina; }
        
        function showMapSelection() { 
            gameState = 'mapSelection'; 
            let mapCardsHTML = maps.map(map => `<div class="map-card" onclick="window.startGame('${map.id}')"><h3 class="card-title text-2xl">${map.name}</h3><p class="card-desc">${map.description}</p></div>`).join(''); 
            let content = `<h1 class="text-4xl mb-4 text-orange-300">Mission Deployment Terminal</h1><p class="text-lg mb-8 text-gray-400">Select your destination.</p><div class="flex flex-col items-center w-full">${mapCardsHTML}</div><button onclick="window.returnToHub()" class="game-button mt-8 text-sm px-6 py-3">Abort Deployment</button>`; 
            showOverlay('mapSelection', content); 
        }
        
        function setupPlayer() { 
            Object.assign(player, { 
                width: 16, height: 24, speed: 200, staminaRegen: 25, dashCost: 40, isDashing: false, dashCooldown: 0, dashDuration: 0.15, dashSpeed: 600, level: 1, xp: 0, xpToNextLevel: 100, xpGainMultiplier: 1.0, fireCooldown: 0, animTimer: 0, animFrame: 0, isMoving: false, 
                inventory: { moondust: 100, alien_chitin: 100, plant_fiber: 100 }, 
                upgrades: { suit_hp: 0, suit_regen: 0, suit_stamina: 0, gun_dmg: 0, gun_rate: 0, gun_proj_speed: 0 } // Initialize new upgrade level
            }); 
            player.baseProjectileSpeed = 300; // Base projectile speed
            applyPermanentUpgrades(); 
        }
        
        function applyPermanentUpgrades() { 
            player.baseMaxHealth = 100 + player.upgrades.suit_hp * 10; 
            player.healthRegen = 0 + player.upgrades.suit_regen * 0.1; 
            player.baseMaxStamina = 100 + player.upgrades.suit_stamina * 10; 
            player.baseAttackPower = 10 + player.upgrades.gun_dmg * 1; 
            player.baseFireRate = 1 * (1 + player.upgrades.gun_rate * 0.05); 
            player.projectileSpeed = player.baseProjectileSpeed + player.upgrades.gun_proj_speed * 10; // Apply projectile speed upgrade
        }

        function resetForMission() {
            applyPermanentUpgrades();
            player.maxHealth = player.baseMaxHealth; player.health = player.maxHealth; 
            player.maxStamina = player.baseMaxStamina; player.stamina = player.maxStamina;
            player.attackPower = player.baseAttackPower; player.fireRate = player.baseFireRate;
            player.x = canvas.width / 2; player.y = canvas.height / 2; timer = gameDuration;
            [enemies, playerProjectiles, enemyProjectiles, shards, materialDrops, terrain].forEach(arr => arr.length = 0);
            const terrainCount = 25;
            if (activeMap.id === 'planet_v2') { for(let i=0; i<terrainCount; i++) terrain.push({ type: 'shrub', x: Math.random() * canvas.width, y: Math.random() * canvas.height }); } 
            else if (activeMap.id === 'cratered_moon') { for(let i=0; i<terrainCount; i++) { terrain.push({ type: 'rock', subType: Math.ceil(Math.random()*2), x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 20 }); } } 
            else if (activeMap.id === 'verdant_prime') { for(let i=0; i<terrainCount; i++) { terrain.push({ type: 'plant', subType: Math.ceil(Math.random()*3), x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 15 }); } } 
            if (activeMap.resources.includes('moondust')) { for(let i=0; i<5; i++) terrain.push({ type: 'resource_node', material: 'moondust', x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 15, health: 30, maxHealth: 30 }); } 
            if (activeMap.resources.includes('plant_fiber')) { for(let i=0; i<5; i++) terrain.push({ type: 'resource_node', material: 'plant_fiber', x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 15, health: 30, maxHealth: 30 }); } 
            waveConfig = { spawnInterval: 3, lastSpawnTime: 0 };
        }
        
        function updatePlayer(deltaTime) {
            let nextX = player.x; let nextY = player.y;
            player.dashCooldown -= deltaTime; player.fireCooldown -= deltaTime;
            player.stamina = Math.min(player.maxStamina, player.stamina + player.staminaRegen * deltaTime);
            if(gameState === 'playing') player.health = Math.min(player.maxHealth, player.health + player.healthRegen * deltaTime);

            let moveDirection = { x: 0, y: 0 };
            if (keys.a) moveDirection.x -= 1; if (keys.d) moveDirection.x += 1;
            if (keys.w) moveDirection.y -= 1; if (keys.s) moveDirection.y += 1;
            player.isMoving = (moveDirection.x !== 0 || moveDirection.y !== 0);

            if(player.isMoving) {
                player.animTimer += deltaTime;
                if(player.animTimer > 0.2) { player.animTimer = 0; player.animFrame = (player.animFrame + 1) % 2; }
                const currentSpeed = player.isDashing ? player.dashSpeed : player.speed;
                const magnitude = Math.sqrt(moveDirection.x**2 + moveDirection.y**2);
                if (magnitude > 0) { // Normalize movement vector
                    nextX += (moveDirection.x / magnitude) * currentSpeed * deltaTime;
                    nextY += (moveDirection.y / magnitude) * currentSpeed * deltaTime;
                }
            } else { player.animFrame = 0; }
            
            // Collision detection with terrain
            let collided = false;
            terrain.forEach(t => { 
                if(t.type === 'rock' || t.type === 'plant') {
                    // Simple circle collision
                    if (Math.hypot(nextX - t.x, nextY - t.y) < t.radius + player.width / 2) { 
                        collided = true; 
                    } 
                } 
            });
            if (!collided) { 
                player.x = nextX; 
                player.y = nextY; 
            }
            
            // Boundary checks
            const bounds = (gameState === 'starbase_hub' || gameState === 'station_menu') ? starbaseHub.rect : {x: 0, y: 0, width: canvas.width, height: canvas.height};
            player.x = Math.max(bounds.x + player.width/2, Math.min(bounds.x + bounds.width - player.width/2, player.x));
            player.y = Math.max(bounds.y + player.height/2, Math.min(bounds.y + bounds.height - player.height/2, player.y));
        }
        
        function updateHub(deltaTime) {
            updatePlayer(deltaTime);
            interactionTarget = null;
            for (const item of starbaseHub.interactables) {
                if(Math.hypot(player.x - item.x, player.y - item.y) < starbaseHub.interactionRadius) {
                    interactionTarget = item; break;
                }
            }
        }

        function createShard(x, y, value) { shards.push({x, y, value, radius: 4}); }
        function createMaterialDrop(x, y, type) { materialDrops.push({ x, y, type }); }
        
        function updateEnemies(deltaTime) {
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.x += p.vx * p.speed * deltaTime; p.y += p.vy * p.speed * deltaTime;
                p.lifespan -= deltaTime;
                if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height || p.lifespan <= 0) {
                    enemyProjectiles.splice(i, 1); continue;
                }
                if (Math.hypot(p.x - player.x, p.y - player.y) < player.width/2 + p.radius) {
                    player.health -= p.damage; enemyProjectiles.splice(i, 1);
                    if (player.health <= 0) { gameState = 'gameOver'; }
                }
            }
            enemies.forEach(enemy => {
                const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                if (enemy.type === 'charger') {
                    if (enemy.state === 'moving') {
                        if (distToPlayer < enemy.attackRadius * 0.8) { enemy.state = 'charging'; enemy.chargeTimer = 0; }
                        else { enemy.x += Math.cos(angle) * enemy.speed * deltaTime; enemy.y += Math.sin(angle) * enemy.speed * deltaTime; }
                    } else if (enemy.state === 'charging') {
                        enemy.chargeTimer += deltaTime;
                        if (enemy.chargeTimer >= enemy.chargeTime) {
                            enemy.state = 'attacking';
                            if (distToPlayer < enemy.attackRadius) {
                                player.health -= enemy.attackDamage;
                                if (player.health <= 0) { gameState = 'gameOver';}
                            } 
                            // Reset to moving after a short attack animation/delay
                            setTimeout(() => { if (enemy) enemy.state = 'moving'; }, 500); 
                        }
                    }
                } else if (enemy.type === 'spitter') {
                    enemy.fireCooldown -= deltaTime;
                    if (distToPlayer > enemy.preferredDist) { enemy.x += Math.cos(angle) * enemy.speed * deltaTime; enemy.y += Math.sin(angle) * enemy.speed * deltaTime; }
                    else { enemy.x -= Math.cos(angle) * enemy.speed * 0.5 * deltaTime; enemy.y -= Math.sin(angle) * enemy.speed * 0.5 * deltaTime; }
                    if (enemy.fireCooldown <= 0) { fireEnemyProjectile(enemy); }
                }
            });
        }
        function createEnemy() { 
            const spitterChance = timer < 90 ? 0.35 : 0.15; // Increased chance for spitters later
            const type = Math.random() > (1 - spitterChance) ? 'spitter' : 'charger'; 
            let x, y; 
            const size = type === 'charger' ? 16 : 12; 
            // Spawn enemies off-screen
            const edge = Math.floor(Math.random() * 4); 
            if (edge === 0) { x = Math.random() * canvas.width; y = -size; } // Top
            else if (edge === 1) { x = canvas.width + size; y = Math.random() * canvas.height; } // Right
            else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + size; } // Bottom
            else { x = -size; y = Math.random() * canvas.height; } // Left

            let newEnemy = { x, y, size, health: type === 'charger' ? 20 : 30, maxHealth: type === 'charger' ? 20 : 30, xpValue: type === 'charger' ? 20 : 30, type: type }; 
            if (type === 'charger') { 
                Object.assign(newEnemy, { speed: 50 + Math.random() * 50, state: 'moving', chargeTime: 1.5, chargeTimer: 0, attackRadius: size * 4, attackDamage: 10, }); 
            } else { 
                Object.assign(newEnemy, { speed: 40 + Math.random() * 30, state: 'moving', preferredDist: 250 + Math.random() * 100, fireCooldown: 1, fireRate: 0.5, }); 
            } 
            enemies.push(newEnemy); 
        };
        function fireEnemyProjectile(enemy) { 
            enemy.fireCooldown = 1 / enemy.fireRate; 
            const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x); 
            for(let i = -1; i <= 1; i++) { // Fires 3 projectiles in a small arc
                const angle = baseAngle + i * 0.2; 
                enemyProjectiles.push({ x: enemy.x, y: enemy.y, radius: 5, color: '#A3E635', speed: 150, vx: Math.cos(angle), vy: Math.sin(angle), damage: 8, lifespan: 1.5 }); 
            } 
        };
        function startDash() { 
            player.isDashing = true; player.stamina -= player.dashCost; player.dashCooldown = 0.5; 
            setTimeout(() => player.isDashing = false, player.dashDuration * 1000); 
        };
        function fireProjectile() { 
            player.fireCooldown = 1 / player.fireRate; 
            const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x); 
            playerProjectiles.push({ x: player.x, y: player.y, radius: 4, color: '#FBBF24', speed: player.projectileSpeed, vx: Math.cos(angle), vy: Math.sin(angle), damage: player.attackPower }); 
        };
        
        function updatePlaying(deltaTime) {
            if (gameState !== 'playing') return;
            timer -= deltaTime; 
            if (timer <= 0) { 
                gameState = 'victory'; 
                // Set the game state to 'victory' and let the gameLoop handle the overlay display
                return; 
            }
            updatePlayer(deltaTime);
            updateEnemies(deltaTime);

            waveConfig.lastSpawnTime += deltaTime; 
            if (timer < 90) waveConfig.spawnInterval = 2.5; 
            else if (timer < 60) waveConfig.spawnInterval = 1.5; 
            else if (timer < 30) waveConfig.spawnInterval = 0.8;
            
            if (waveConfig.lastSpawnTime > waveConfig.spawnInterval) {
                waveConfig.lastSpawnTime = 0; 
                const spawnCount = 1 + Math.floor((gameDuration - timer) / 40);
                for(let i=0; i<spawnCount; i++) createEnemy();
            }
            
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const p = playerProjectiles[i];
                p.x += p.vx * p.speed * deltaTime; p.y += p.vy * p.speed * deltaTime;
                if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) { playerProjectiles.splice(i, 1); continue; }
                let hit = false;
                // Collision with resource nodes (terrain)
                for (let t_idx = terrain.length - 1; t_idx >= 0; t_idx--) { // Iterate backwards for safe removal
                    const t = terrain[t_idx];
                    if(t.type !== 'resource_node') continue; // Only interact with resource nodes
                    if (Math.hypot(p.x - t.x, p.y - t.y) < t.radius + p.radius) { 
                        t.health -= p.damage; 
                        if (t.health <= 0) { 
                            createMaterialDrop(t.x, t.y, t.material); 
                            terrain.splice(t_idx, 1); // Remove destroyed node
                        } 
                        playerProjectiles.splice(i, 1); // Remove projectile
                        hit = true; 
                        break; // Projectile hit something, move to next projectile
                    }
                }
                if (hit) continue; // If projectile hit terrain, skip enemy collision check for this projectile

                // Collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) { // Iterate backwards for safe removal
                    const e = enemies[j];
                    if (Math.hypot(p.x - e.x, p.y - e.y) < e.size) { // Simple circle collision
                        e.health -= p.damage; 
                        playerProjectiles.splice(i, 1); // Remove projectile
                        if (e.health <= 0) {
                            createShard(e.x, e.y, e.xpValue);
                            if (Math.random() < 0.3) createMaterialDrop(e.x, e.y, 'alien_chitin');
                            enemies.splice(j,1); // Remove defeated enemy
                        } 
                        break; // Projectile hit an enemy, move to next projectile
                    }
                }
            }
            
            // Pickup shards and materials
            for (let i = shards.length - 1; i >= 0; i--) { 
                if (Math.hypot(player.x - shards[i].x, player.y - shards[i].y) < player.width * 4) { 
                    gainXp(shards[i].value); 
                    shards.splice(i, 1); 
                } 
            }
            for (let i = materialDrops.length - 1; i >= 0; i--) { 
                if (Math.hypot(player.x - materialDrops[i].x, player.y - materialDrops[i].y) < player.width * 4) { 
                    player.inventory[materialDrops[i].type]++; 
                    materialDrops.splice(i, 1); 
                } 
            }
        }
        
        function gainXp(amount) { 
            player.xp += amount * player.xpGainMultiplier; 
            if (player.xp >= player.xpToNextLevel) levelUp(); 
        }
        
        function levelUp() { 
            player.level++; 
            player.xp -= player.xpToNextLevel; 
            player.xpToNextLevel = Math.floor(100 * Math.pow(1.5, player.level - 1)); 
            presentUpgradeChoices(); 
        }
        
        function presentUpgradeChoices() { 
            gameState = 'paused'; 
            // Get 3 unique random power-ups
            const choices = [...powerUps].sort(() => 0.5 - Math.random()).slice(0, 3); 
            let cardsHTML = `<div class="w-full flex justify-center">${choices.map(upgrade => `
                <div class="upgrade-card" onclick="window.selectUpgrade('${upgrade.id}')">
                    <h2 class="card-title">${upgrade.title}</h2>
                    <p class="card-desc">${upgrade.desc}</p>
                </div>`).join('')}</div>`; 
            showOverlay('levelUpSelection', `<h1 class="text-4xl mb-8 text-green-300">System Upgrade Available</h1>${cardsHTML}`); 
        }
        window.selectUpgrade = (upgradeId) => { 
            const upgrade = powerUps.find(u=>u.id === upgradeId); 
            upgrade.apply(player); 
            showOverlay(null); 
            gameState = 'playing'; 
        }

        // Station Menu (Workshop/Armory) logic
        function openStationMenu(stationId) {
            gameState = 'station_menu';
            activeStation = stationId;
            selectedUpgradeId = null; // Clear any previously selected upgrade
            
            const stationMenuTitleEl = document.getElementById('stationMenuTitle');
            const upgradeIconsContainerEl = document.getElementById('upgradeIconsContainer');
            const upgradeDetailsBoxEl = document.getElementById('upgradeDetailsBox');

            stationMenuTitleEl.textContent = `${stationId.charAt(0).toUpperCase() + stationId.slice(1)} Upgrades`;
            upgradeIconsContainerEl.innerHTML = ''; // Clear previous icons
            upgradeDetailsBoxEl.style.display = 'none'; // Hide details box initially

            const upgradesForStation = permanentUpgrades[stationId];

            upgradesForStation.forEach(upgrade => {
                const currentLevel = player.upgrades[upgrade.id];
                const isMaxLevel = currentLevel >= upgrade.maxLevel;
                const cost = upgrade.cost(currentLevel);
                let canAfford = true;
                for(const mat in cost) { 
                    if(player.inventory[mat] < cost[mat]) canAfford = false; 
                }

                const iconButton = document.createElement('div');
                iconButton.className = `upgrade-icon-button ${isMaxLevel ? 'is-max' : ''} ${canAfford ? 'can-afford' : ''}`;
                iconButton.innerHTML = `${upgrade.icon}<br><span class="icon-text">${upgrade.name}</span>`;
                iconButton.onclick = () => window.displayUpgradeDetails(upgrade.id);
                upgradeIconsContainerEl.appendChild(iconButton);
            });

            showOverlay('stationMenu');
        }

        // Function to display upgrade details in the bottom box
        window.displayUpgradeDetails = (upgradeId) => {
            selectedUpgradeId = upgradeId; // Set the currently selected upgrade
            const upgrade = permanentUpgrades[activeStation].find(u => u.id === upgradeId);
            if (!upgrade) return;

            const currentLevel = player.upgrades[upgrade.id];
            const isMaxLevel = currentLevel >= upgrade.maxLevel;
            const cost = upgrade.cost(currentLevel);
            let canAfford = true;
            let costHtml = '';

            for(const mat in cost) { 
                if(player.inventory[mat] < cost[mat]) canAfford = false; 
                costHtml += `<span style="color:${materials[mat].color};">${cost[mat]} ${materials[mat].name}</span> `;
            }

            const detailTitleEl = document.getElementById('detailTitle');
            const detailDescEl = document.getElementById('detailDesc');
            const detailLevelEl = document.getElementById('detailLevel');
            const detailCostEl = document.getElementById('detailCost');
            const detailBuyButtonEl = document.getElementById('detailBuyButton');
            const upgradeDetailsBoxEl = document.getElementById('upgradeDetailsBox');

            detailTitleEl.textContent = upgrade.name;
            detailDescEl.textContent = upgrade.desc;
            detailLevelEl.textContent = `Level: ${currentLevel}/${upgrade.maxLevel}`;
            detailCostEl.innerHTML = isMaxLevel ? 'Max Level Reached' : `Cost: ${costHtml}`;

            detailBuyButtonEl.textContent = isMaxLevel ? 'MAX LEVEL' : 'UPGRADE';
            detailBuyButtonEl.className = `game-button mt-4 w-full ${canAfford && !isMaxLevel ? '' : 'disabled'}`;
            detailBuyButtonEl.disabled = isMaxLevel || !canAfford;
            detailBuyButtonEl.onclick = () => window.buyUpgrade(upgrade.id);

            upgradeDetailsBoxEl.style.display = 'flex'; // Show the details box

            // Highlight selected icon
            document.querySelectorAll('.upgrade-icon-button').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.onclick.toString().includes(`'${upgradeId}'`)) { // Simple way to check which button corresponds
                    btn.classList.add('selected');
                }
            });
        };
        
        // Function to handle buying upgrades
        window.buyUpgrade = (upgradeId) => {
            const upgrade = permanentUpgrades[activeStation].find(u => u.id === upgradeId);
            const currentLevel = player.upgrades[upgradeId];
            if (currentLevel >= upgrade.maxLevel) return;

            const cost = upgrade.cost(currentLevel);
            let canAfford = true;
            for(const mat in cost) { 
                if(player.inventory[mat] < cost[mat]) canAfford = false; 
            }

            if(canAfford) {
                for(const mat in cost) { player.inventory[mat] -= cost[mat]; }
                player.upgrades[upgradeId]++;
                applyPermanentUpgrades(); 
                window.displayUpgradeDetails(upgradeId); // Re-display details for current upgrade to reflect new level/cost
                // Also update material counts in the HUD instantly
                let matHTML = 'INVENTORY:<br>'; 
                let hasMats = false;
                for(const mat in player.inventory) {
                    if(player.inventory[mat] > 0) {
                        matHTML += `<span style="color:${materials[mat].color};">${materials[mat].name}: ${player.inventory[mat]}</span><br>`;
                        hasMats = true;
                    }
                }
                document.getElementById('hud-materials').innerHTML = hasMats ? matHTML : '';
            } else {
                console.log("Cannot afford this upgrade!");
            }
        };

        // Function to close the station menu
        window.closeStationMenu = () => {
            showOverlay(null);
            gameState = 'starbase_hub';
            activeStation = null;
            selectedUpgradeId = null;
        };

        function drawHUD() {
            const barWidth = 200; 
            ctx.font = '24px "Press Start 2P"'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; 
            const minutes = Math.floor(timer / 60).toString().padStart(2, '0'); 
            const seconds = Math.floor(timer % 60).toString().padStart(2, '0'); 
            ctx.fillText(`${minutes}:${seconds}`, canvas.width / 2, 40); 
            
            // Health Bar
            ctx.fillStyle = '#4B5563'; ctx.fillRect(10, canvas.height - 50, barWidth, 20); 
            ctx.fillStyle = '#22C55E'; ctx.fillRect(10, canvas.height - 50, barWidth * (player.health / player.maxHealth), 20); 
            ctx.strokeStyle = 'white'; ctx.strokeRect(10, canvas.height - 50, barWidth, 20); 
            
            // Stamina Bar
            ctx.fillStyle = '#4B5563'; ctx.fillRect(10, canvas.height - 25, barWidth, 10); 
            ctx.fillStyle = '#F59E0B'; ctx.fillRect(10, canvas.height - 25, barWidth * (player.stamina / player.maxStamina), 10); 
            
            // XP Bar
            const xpBarWidth = canvas.width - 20; 
            ctx.fillStyle = '#4B5563'; ctx.fillRect(10, canvas.height - 10, xpBarWidth, 5); 
            ctx.fillStyle = '#A78BFA'; ctx.fillRect(10, canvas.height - 10, xpBarWidth * (player.xp / player.xpToNextLevel), 5); 
            
            // Level Text
            ctx.font = '16px "Press Start 2P"'; ctx.fillStyle = 'white'; ctx.textAlign = 'left'; 
            ctx.fillText(`LVL: ${player.level}`, 15, canvas.height - 60);
            
            // Materials HUD
            let matHTML = 'INVENTORY:<br>'; 
            let hasMats = false;
            for(const mat in player.inventory) {
                if(player.inventory[mat] > 0) {
                    matHTML += `<span style="color:${materials[mat].color};">${materials[mat].name}: ${player.inventory[mat]}</span><br>`;
                    hasMats = true;
                }
            }
            document.getElementById('hud-materials').innerHTML = hasMats ? matHTML : '';
        }

        function drawHub() {
            sprites.drawStarbase(ctx, canvas.width, canvas.height, globalAnimTimer);
            sprites.drawTableAndChairs(ctx, starbaseHub.table.x, starbaseHub.table.y);
            sprites.drawBed(ctx, starbaseHub.bed.x, starbaseHub.bed.y, starbaseHub.bed.width, starbaseHub.bed.height);
            sprites.drawKitchen(ctx, starbaseHub.kitchen.x, starbaseHub.kitchen.y, starbaseHub.kitchen.width, starbaseHub.kitchen.height);
            starbaseHub.interactables.forEach(item => {
                if(item.id === 'deploy') { // Explicitly draw terminal with its animation
                    sprites.drawTerminal(ctx, item.x, item.y, item.width, item.height, globalAnimTimer);
                } else if(item.id === 'workshop') {
                    sprites.drawWorkshop(ctx, item.x, item.y, item.width, item.height);
                } else if(item.id === 'armory') {
                    sprites.drawArmory(ctx, item.x, item.y, item.width, item.height);
                } else if(item.id === 'database') {
                    // Draw database with its own distinct sprite function
                    sprites.drawDatabase(ctx, item.x, item.y, item.width, item.height);
                } else if(item.id === 'bed') {
                    sprites.drawBed(ctx, item.x, item.y, item.width, item.height);
                } else if(item.id === 'kitchen') {
                    sprites.drawKitchen(ctx, item.x, item.y, item.width, item.height);
                }
            });
            if(interactionTarget) {
                ctx.font = '14px "Press Start 2P"'; ctx.fillStyle = '#FB923C'; ctx.textAlign = 'center';
                const yPos = interactionTarget.y - interactionTarget.height * 0.7;
                let xPos = interactionTarget.x;
                const textWidth = ctx.measureText(`[E] Use ${interactionTarget.name}`).width;
                if(xPos - textWidth/2 < 10) xPos = textWidth/2 + 10;
                if(xPos + textWidth/2 > canvas.width - 10) xPos = canvas.width - textWidth/2 - 10;
                
                ctx.fillText(`[E] Use`, xPos, yPos);
                ctx.fillText(`${interactionTarget.name}`, xPos, yPos + 16);
            }
            sprites.drawPlayer(ctx, player.x, player.y, player.animFrame, mouse.facingRight);
        }

        function drawPlaying() {
            sprites.drawPlanetFloor(ctx, canvas.width, canvas.height);
            terrain.forEach(t => {
                if (t.type === 'rock') sprites.drawRock(ctx, t.x, t.y, t.subType);
                else if (t.type === 'plant') sprites.drawPlant(ctx, t.x, t.y, t.subType);
                else if (t.type === 'shrub') sprites.drawShrub(ctx, t.x, t.y);
                else if (t.type === 'resource_node') sprites.drawResourceNode(ctx, t);
            });
            shards.forEach(s => { ctx.fillStyle = '#67E8F9'; ctx.beginPath(); ctx.arc(s.x, s.y, 4, 0, Math.PI * 2); ctx.fill(); });
            materialDrops.forEach(d => sprites.drawMaterial(ctx, d.x, d.y, d.type));
            enemyProjectiles.forEach(p => { 
                const alpha = Math.min(1, p.lifespan / 0.5); 
                ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(Math.atan2(p.vy, p.vx)); 
                ctx.fillStyle = `rgba(163, 230, 53, ${alpha})`; ctx.fillRect(-7, -2, 14, 4); 
                ctx.restore(); 
            });
            enemies.forEach(e => {
                if (e.type === 'charger') {
                    sprites.drawCharger(ctx, e.x, e.y);
                    if (e.state === 'charging') {
                        const prog = e.chargeTimer / e.chargeTime;
                        ctx.fillStyle = `rgba(220, 38, 38, 0.3)`; ctx.beginPath(); ctx.arc(e.x, e.y, e.attackRadius * prog, 0, Math.PI * 2); ctx.fill();
                        ctx.strokeStyle = `rgba(239, 68, 68, 0.7)`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(e.x, e.y, e.attackRadius, 0, Math.PI * 2); ctx.stroke();
                    }
                } else if (e.type === 'spitter') { sprites.drawSpitter(ctx, e.x, e.y); }
                const hp = e.health / e.maxHealth;
                if(e.health > 0 && hp < 1){ ctx.fillStyle = '#4B5563'; ctx.fillRect(e.x - e.size, e.y - e.size - 5, e.size * 2, 4); ctx.fillStyle = '#F87171'; ctx.fillRect(e.x - e.size, e.y - e.size - 5, e.size * 2 * hp, 4); }
            });
            playerProjectiles.forEach(p => { 
                ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); 
            });
            sprites.drawPlayer(ctx, player.x, player.y, player.animFrame, mouse.facingRight);
            drawHUD();
        }
        
        // This function is now empty as the station menu UI is handled by HTML overlay
        function drawStationMenu() {
            // No direct canvas drawing for the menu background or title.
            // The HTML overlay handles this.
            // drawHub() is called by gameLoop to ensure the base scene is drawn.
        }
        
        function gameLoop(currentTime) {
            // Calculate delta time for consistent animation regardless of frame rate
            const deltaTime = (currentTime - lastTime) / 1000 || 0;
            lastTime = currentTime;
            globalAnimTimer += deltaTime;
            if (player.animTimer !== undefined) player.animTimer += deltaTime;
            
            // Update game state based on current gameState
            if (gameState === 'starbase_hub' || gameState === 'station_menu') { 
                updateHub(deltaTime); // Update player movement in hub, even if menu is open
            } else if (gameState === 'playing') { 
                updatePlaying(deltaTime); 
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw based on current gameState
            if (gameState === 'starbase_hub' || gameState === 'station_menu') { 
                drawHub(); // Draw the hub background and interactables
            } else if (gameState === 'playing' || gameState === 'paused') { 
                drawPlaying(); // Draw gameplay elements
            }
            // The 'station_menu' overlay is handled by HTML/CSS, not canvas drawing.
            
            // Handle game over or victory states
            if (gameState === 'gameOver' || gameState === 'victory') {
                drawPlaying(); // Draw final game state before overlay
                showOverlay(gameState); // Show the appropriate overlay
                if(gameLoopId) cancelAnimationFrame(gameLoopId); // Stop the game loop
                return; // Exit loop
            }
            
            // Request next animation frame
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        // Initialization function
        function init() {
            // Set up static overlay content
            const genericButton = `onclick="window.returnToHub()" class="game-button"`;
            const overlays = { 
                gameOver: `<h1 class="text-5xl mb-4 text-red-500">Mission Failed</h1><p class="text-lg mb-12 text-gray-300">You have been overrun.</p><button ${genericButton}>Return to Hangar</button>`, 
                victory: `<h1 class="text-5xl mb-4 text-green-400">Mission Accomplished</h1><p class="text-lg mb-12 text-gray-300">Welcome back, survivor.</p><button ${genericButton}>Return to Hangar</button>`
            };
            for(const [id, content] of Object.entries(overlays)) { document.getElementById(id).innerHTML = content; }
            
            // Event Listeners
            window.addEventListener('resize', setCanvasDimensions);
            window.addEventListener('keydown', e => { 
                const key = e.key.toLowerCase(); 
                if(keys.hasOwnProperty(key)) keys[key] = true; 
                if (key === ' ' && gameState === 'playing' && player.stamina >= player.dashCost && player.dashCooldown <= 0) {
                    startDash(); 
                }
                if (key === 'e' && (gameState === 'starbase_hub' || gameState === 'station_menu') && interactionTarget) { 
                    handleInteraction(interactionTarget.id); 
                }
            });
            window.addEventListener('keyup', e => { 
                if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; 
            });
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
                // Determine player facing direction
                mouse.facingRight = mouse.x > player.x;
            });
            canvas.addEventListener('mousedown', e => {
                if (e.button === 0) mouse.click = true; // Left click
            });
            canvas.addEventListener('mouseup', e => {
                if (e.button === 0) mouse.click = false;
            });

            // Initialize player, dimensions, textures, and start game loop
            setupPlayer();
            setCanvasDimensions();
            createTextures();
            returnToHub(); // Start at the starbase hub
        }

        // Run initialization when the script loads
        init();

        // Mouse update loop
        function mouseLoop() {
            // Check for continuous firing if left mouse button is held down
            if (mouse.click && gameState === 'playing' && player.fireCooldown <= 0) {
                fireProjectile();
            }
            requestAnimationFrame(mouseLoop);
        }
        mouseLoop(); // Start the mouse loop
    })();
    </script>
</body>
</html>
