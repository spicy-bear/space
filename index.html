<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starbase Survivor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        font-family: 'Press Start 2P', cursive;
        background-color: #111827;
        color: #F3F4F6;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
      }

      #game-container {
        width: 100%;
        max-width: 1000px;
        aspect-ratio: 16 / 9;
        background-color: #000;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(251, 146, 60, 0.4);
        position: relative;
        cursor: crosshair;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        image-rendering: pixelated;
      }

      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        background-color: rgba(17, 24, 39, 0.9);
        border-radius: 8px;
        transition: opacity 0.3s ease-in-out;
        padding: 1rem; /* Slightly reduced overall overlay padding to maximize content area */
        box-sizing: border-box;
        height: 100%; /* Ensure overlay fills height */
        width: 100%; /* Ensure overlay fills width */
        justify-content: flex-start; /* Align content to top */
      }

      .overlay-hidden {
        opacity: 0;
        pointer-events: none;
      }

      .game-button {
        background-color: #FB923C;
        color: #111827;
        padding: 1rem 2rem;
        border-radius: 8px;
        text-transform: uppercase;
        font-size: 1.25rem;
        cursor: pointer;
        border: 2px solid #FDBA74;
        box-shadow: 0 4px #C2410C;
        transition: all 0.1s ease-in-out;
      }

      .game-button:hover:not(:disabled) {
        background-color: #FDBA74;
        transform: translateY(-2px);
        box-shadow: 0 6px #C2410C;
      }

      .game-button:active:not(:disabled) {
        transform: translateY(2px);
        box-shadow: 0 2px #C2410C;
      }

      .game-button:disabled {
        background-color: #4b5563;
        color: #9ca3af;
        cursor: not-allowed;
        box-shadow: none;
      }

      .map-cards-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Responsive grid columns */
        gap: 1.5rem; /* Space between cards */
        width: 100%;
        padding: 1.5rem;
        box-sizing: border-box;
        overflow-y: auto; /* Allow scrolling if many maps */
        max-height: 80vh; /* Increased max-height to give more room */
      }

      .map-card {
        background-color: #374151;
        border: 2px solid #9CA3AF;
        border-radius: 8px;
        padding: 1.5rem; /* Increased padding */
        text-align: left;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* Ensure specific items within overlay don't shrink */
      .overlay > *:not(.flex-grow) {
        flex-shrink: 0;
      }

      .map-card:hover {
        transform: translateY(-5px);
        border-color: #FB923C;
        background-color: #4B5563;
      }

      .map-card h3 {
        color: #FDBA74;
      }

      .upgrade-card {
        background-color: #374151;
        border: 2px solid #9CA3AF;
        border-radius: 8px;
        padding: 1rem;
        margin: 0 1rem;
        width: 28%;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
      }

      .upgrade-card:hover {
        transform: translateY(-5px);
        border-color: #FB923C;
        background-color: #4B5563;
      }

      .card-title {
        font-size: 1.1rem;
        color: #FB923C;
        margin-bottom: 0.75rem;
      }

      .card-desc {
        font-size: 0.8rem;
        color: #D1D5DB;
      }

      #hud-materials {
        position: absolute;
        top: 15px;
        left: 15px;
        background-color: rgba(17, 24, 39, 0.7);
        padding: 8px;
        border-radius: 5px;
        font-size: 10px;
        text-align: left;
        line-height: 1.5;
        z-index: 5;
      }

      /* Station Menu */
      .station-menu-content {
        width: 90%;
        max-width: 800px;
      }

      .upgrade-cost {
        font-size: 0.7rem;
        color: #fca5a5;
        margin-top: 0.5rem;
      }

      /* Icon-based upgrade selection */
      .icon-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1rem; /* Space between icons */
        width: 100%;
        max-width: 800px; /* Adjust as needed */
        margin-bottom: 2rem;
      }

      .upgrade-icon-button {
        background-color: #374151;
        border: 2px solid #6b7280;
        border-radius: 8px;
        padding: 1rem;
        width: 120px; /* Fixed width for icons */
        height: 120px; /* Fixed height for icons */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        font-size: 40px; /* Icon size */
        line-height: 1.2;
        color: #FDBA74; /* Icon color */
      }

      .upgrade-icon-button:hover {
        transform: translateY(-5px);
        border-color: #FB923C;
        background-color: #4B5563;
      }

      .upgrade-icon-button.selected {
        border-color: #4ade80; /* Highlight color for selected icon */
        box-shadow: 0 0 15px rgba(74, 222, 128, 0.5);
      }

      /* Style for equipped items */
      .upgrade-icon-button.equipped {
        border-color: #818cf8; /* A different highlight for equipped */
      }

      .upgrade-icon-button.can-afford {
        border-color: #a3e635;
      }

      .upgrade-icon-button.is-max {
        border-color: #f97316;
      }

      .upgrade-icon-button .icon-text {
        font-size: 0.75rem; /* Smaller text for icon label */
        margin-top: 0.5rem;
        color: #D1D5DB;
        text-transform: uppercase;
      }

      #upgradeDetailsBox {
        background-color: #1f2937;
        padding: 1.5rem;
        border-radius: 8px;
        border: 2px solid #6b7280;
        width: 90%;
        max-width: 600px;
        text-align: left;
        margin-top: 1rem;
        box-shadow: 0 0 10px rgba(251, 146, 60, 0.2);
        display: none; /* Hidden by default */
        flex-direction: column;
        justify-content: space-between;
      }

      #upgradeDetailsBox h3 {
        font-size: 1.5rem;
        color: #FB923C;
        margin-bottom: 0.5rem;
      }

      #upgradeDetailsBox p {
        font-size: 0.9rem;
        color: #D1D5DB;
        margin-bottom: 0.5rem;
      }

      #upgradeDetailsBox .cost-text {
        color: #fca5a5;
        font-size: 0.8rem;
        margin-top: 0.75rem;
      }

      /* Tabbed menu in Armory */
      .station-tabs {
        display: flex;
        margin-bottom: 1.5rem;
        width: 100%;
        justify-content: center;
      }

      .station-tab {
        padding: 0.75rem 1.5rem;
        background-color: #374151;
        border: 2px solid #6b7280;
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        cursor: pointer;
        font-size: 1rem;
        color: #D1D5DB;
        transition: all 0.2s ease-in-out;
        margin: 0 0.25rem;
      }

      .station-tab.active {
        background-color: #1f2937;
        border-color: #FB923C;
        color: #FB923C;
      }

      .station-tab:hover:not(.active) {
        background-color: #4B5563;
      }

      .tab-content {
        width: 100%;
        display: none;
        flex-direction: column;
        align-items: center;
      }

      .tab-content.active {
        display: flex;
      }

      .message-box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #1f2937;
        border: 2px solid #f97316;
        border-radius: 8px;
        padding: 2rem;
        text-align: center;
        z-index: 100;
        box-shadow: 0 0 20px rgba(251, 146, 60, 0.4);
        display: none; /* Hidden by default */
      }

      .message-box button {
        margin-top: 1rem;
      }

      /* Database Styles */
      .database-entry {
        display: flex;
        align-items: center;
        background-color: #374151;
        border: 2px solid #9CA3AF;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        width: 80%;
        max-width: 600px;
        text-align: left;
      }

      .database-entry-icon {
        width: 80px;
        height: 80px;
        margin-right: 1.5rem;
        background-color: #2d3540; /* Slightly different background for icon */
        border-radius: 8px;
        flex-shrink: 0;
        display: flex; /* For centering content inside */
        align-items: center;
        justify-content: center;
      }

      .database-entry-details {
        flex-grow: 1;
      }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Abort Mission Button -->
    <button id="abortMissionButton" class="game-button absolute top-4 right-4 text-sm px-4 py-2"
            style="z-index: 5; display: none;">Abort Mission
    </button>
    <!-- Auto-Shoot Toggle -->
    <button id="autoShootToggle" class="game-button absolute top-[68px] right-4 text-sm px-4 py-2"
            style="z-index: 5; display: none;">Auto-Shoot: OFF
    </button>

    <div id="mapSelection" class="overlay overlay-hidden"></div>
    <div id="levelUpSelection" class="overlay overlay-hidden"></div>
    <div id="stationMenu" class="overlay overlay-hidden">
        <h1 class="text-4xl mb-8 text-orange-300" id="stationMenuTitle"></h1>

        <div class="station-tabs">
            <div class="station-tab active" data-tab="weapons">Weapons</div>
            <div class="station-tab" data-tab="upgrades">Upgrades</div>
        </div>

        <div id="weaponsTabContent" class="tab-content active">
            <div id="weaponIconsContainer" class="icon-container"></div>
        </div>

        <div id="upgradesTabContent" class="tab-content">
            <div id="upgradeIconsContainer" class="icon-container"></div>
        </div>

        <div id="upgradeDetailsBox">
            <h3 id="detailTitle"></h3>
            <p id="detailDesc"></p>
            <p id="detailLevel"></p>
            <p class="cost-text" id="detailCost"></p>
            <button id="detailBuyButton" onclick="" class="game-button mt-4 w-full"></button>
        </div>

        <button onclick="window.closeStationMenu()" class="game-button mt-8 text-sm px-6 py-3">Return to Starbase
        </button>
    </div>
    <div id="gameOver" class="overlay overlay-hidden"></div>
    <div id="victory" class="overlay overlay-hidden"></div>
    <div id="databaseScreen" class="overlay overlay-hidden"></div>
    <div id="hud-materials"></div>
    <div id="messageBox" class="message-box">
        <p id="messageBoxText" class="mb-4"></p>
        <button class="game-button" onclick="document.getElementById('messageBox').style.display = 'none'">OK</button>
    </div>
</div>

<script>
  (function () {
    // --- Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // --- Game State Variables ---
    let gameState = 'starbase_hub';
    let gameLoopId;
    let lastTime = 0;
    let globalAnimTimer = 0;
    const mouse = {x: 0, y: 0, facingRight: true, click: false, prevClick: false};
    let activeMap = null;
    let activeStation = null;
    let selectedUpgradeId = null;
    let selectedWeaponId = null;

    // --- Entity & Data Arrays ---
    const player = {};
    const rover = {};
    const playerProjectiles = []; // All projectiles, will be differentiated by 'source' property
    const enemyProjectiles = [];
    const enemies = [];
    const shards = [];
    const materialDrops = [];
    const terrain = [];
    const stars = [];
    const drones = [];
    const particles = [];
    const missiles = [];
    const gameDuration = 120;
    let timer = gameDuration;
    let waveConfig = {};
    const keys = {w: false, a: false, s: false, d: false, ' ': false, e: false, x: false, escape: false};
    let interactionTarget = null;
    let orbitalStrike = {
      enabled: false,
      timer: 15,
      cooldown: 15,
      target: null,
      impactTimer: 0,
      explosionRadius: 80,
      damage: 50
    };

    // --- Data Definitions ---
    const starbaseHub = {
      rect: {x: 0, y: 0, width: 0, height: 0},
      terminal: {x: 0, y: 0, width: 80, height: 70, id: 'deploy', name: 'Deployment Terminal'},
      workshop: {x: 0, y: 0, width: 90, height: 60, id: 'workshop', name: 'Workshop'},
      armory: {x: 0, y: 0, width: 60, height: 80, id: 'armory', name: 'Armory'},
      garage: {x: 0, y: 0, width: 100, height: 80, id: 'garage', name: 'Garage'},
      database: {x: 0, y: 0, width: 70, height: 70, id: 'database', name: 'Database'},
      infirmary: {x: 0, y: 0, width: 70, height: 70, id: 'infirmary', name: 'Infirmary'},
      table: {x: 0, y: 0},
      bed: {x: 0, y: 0, width: 120, height: 70, id: 'bed', name: 'Bed'},
      kitchen: {x: 0, y: 0, width: 80, height: 70, id: 'kitchen', name: 'Galley'},
      interactionRadius: 60,
      interactables: [],
    };
    const maps = [
      {
        id: 'planet_v2',
        name: 'Planet V-II',
        description: 'A desolate rock with a mix of fauna. Standard resource distribution.',
        resources: ['moondust', 'alien_chitin']
      },
      {
        id: 'cratered_moon',
        name: 'Cratered Moon',
        description: 'Low gravity, high risk. Craters block sight and movement. Rich in moondust.',
        resources: ['moondust']
      },
      {
        id: 'verdant_prime',
        name: 'Verdant Prime',
        description: 'Lush and overgrown. Flora can provide cover. Rich in organic matter.',
        resources: ['plant_fiber', 'alien_chitin']
      },
      {
        id: 'icy_planet',
        name: 'Glacial Wastes',
        description: 'A frozen world of crystal and ice. Beware of the chilling creatures.',
        resources: ['ice_crystal', 'frost_shard']
      }, // New planet
      {
        id: 'red_planet',
        name: 'Crimson Sands',
        description: 'Barren and hot, with ancient rock formations. Home to aggressive burrowers.',
        resources: ['moondust', 'magma_rock']
      }, // New planet
      {
        id: 'coral_beach',
        name: 'Azure Coast',
        description: 'Tropical islands with clear waters and unique marine life. Rich in organic materials.',
        resources: ['plant_fiber', 'seaweed', 'fin']
      }, // New planet
    ];
    const powerUps = [
      {
        id: 'atk_power', title: 'Power Shot', desc: '+10% Attack Damage',
        apply: p => {
          p.attackPower *= 1.1;
        },
      },
      {
        id: 'atk_speed', title: 'Rapid Fire', desc: '+15% Fire Rate',
        apply: p => {
          p.fireRate *= 1.15;
        },
      },
      {
        id: 'proj_speed', title: 'Hyper-Velocity', desc: '+20% Projectile Speed',
        apply: p => {
          p.projectileSpeed *= 1.2;
        }
      },
      {
        id: 'max_hp', title: 'Titanium Hull', desc: '+25 Max Health',
        apply: p => {
          p.maxHealth += 25;
          p.health = Math.min(p.health + 25, p.maxHealth);
        }
      },
      {
        id: 'hp_regen', title: 'Nano-Repair', desc: 'Regen 1 HP/sec',
        apply: p => {
          p.healthRegen += 1;
        }
      },
      {
        id: 'move_speed', title: 'Servo-Grease', desc: '+10% Move Speed',
        apply: p => {
          p.speed *= 1.1;
        }
      },
      {
        id: 'stamina_regen', title: 'Adrenal Pump', desc: '+20% Stamina Regen',
        apply: p => {
          p.staminaRegen *= 1.2;
        }
      },
      {
        id: 'xp_gain', title: 'Shard Magnet', desc: '+15% XP Gain',
        apply: p => {
          p.xpGainMultiplier *= 1.15;
        }
      },
      {
        id: 'drone_add', title: 'Deploy Drone', desc: 'Adds an automated combat drone (Max 5).',
        apply: p => {
          if (p.drones < 5) p.drones++;
          syncDrones();
        }
      },
      {
        id: 'rover_upgrade',
        title: 'Rover Munitions',
        desc: 'Adds an extra projectile to rover\'s shots (Max 5).',
        apply: p => {
          if (rover.projectilesPerShot < 5) rover.projectilesPerShot++;
        }
      }, // Modified for rover
      {
        id: 'orbital_cooldown',
        title: 'Targeting Computer',
        desc: 'Reduces orbital strike cooldown by 20%.',
        apply: p => {
          p.orbitalCooldownMultiplier *= 0.8;
        }
      },
    ];
    const materials = {
      moondust: {color: '#E5E7EB', name: 'Moondust'},
      alien_chitin: {color: '#FCA5A5', name: 'Alien Chitin'},
      plant_fiber: {color: '#86EFAC', name: 'Plant Fiber'},
      goop: {color: '#9333ea', name: 'Goop'}, // New material
      ice_crystal: {color: '#BFDBFE', name: 'Ice Crystal'}, // New material
      seaweed: {color: '#6EE7B7', name: 'Seaweed'}, // New material
      frost_shard: {color: '#A7D9ED', name: 'Frost Shard'}, // New material for icy planet
      magma_rock: {color: '#FDBA74', name: 'Magma Rock'}, // New material for red planet
      fin: {color: '#F0ABFC', name: 'Fin'}, // New material for beachy planet
    };

    const weapons = {
      'blaster': {
        id: 'blaster',
        name: 'Standard Blaster',
        description: 'Your trusty starting weapon. Balanced fire rate and damage.',
        icon: '🔫',
        baseDamage: 10,
        baseFireRate: 1,
        baseProjectileSpeed: 300,
        cost: {}
      },
      'shotgun': {
        id: 'shotgun',
        name: 'Scattergun',
        description: 'Fires multiple projectiles in a wide cone.',
        icon: '💥',
        baseDamage: 5,
        baseFireRate: 0.7,
        baseProjectileSpeed: 250,
        projectilesPerShot: 3,
        spreadAngle: 0.3,
        cost: {moondust: 100, alien_chitin: 50}
      },
      'phaser': {
        id: 'phaser',
        name: 'Phaser Rifle',
        description: 'Rapid-fire energy bursts. Low damage but high accuracy and speed.',
        icon: '⚡',
        baseDamage: 7,
        baseFireRate: 2,
        baseProjectileSpeed: 400,
        cost: {moondust: 70, plant_fiber: 80}
      },
      'bfg': {
        id: 'bfg',
        name: 'Big Friendly Gun',
        description: 'Slow firing, but devastating. Fires a massive, high-damage projectile that explodes on impact.',
        icon: '💣',
        baseDamage: 50,
        baseFireRate: 0.3,
        baseProjectileSpeed: 200,
        explosionRadius: 60,
        cost: {moondust: 200, alien_chitin: 150, plant_fiber: 100}
      },
    };
    const permanentUpgrades = {
      workshop: [
        {
          id: 'suit_hp', name: 'Reinforce Hull', desc: '+10 Max Health', maxLevel: 10,
          cost: (lvl) => ({moondust: 10 * (lvl + 1)}),
          icon: '❤️',
        },
        {
          id: 'suit_regen', name: 'Nano-bots', desc: '+0.1 HP/sec', maxLevel: 5,
          cost: (lvl) => ({moondust: 20 * (lvl + 1), plant_fiber: 5 * (lvl + 1)}),
          icon: '➕',
        },
        {
          id: 'suit_stamina', name: 'Capacitors', desc: '+10 Max Stamina', maxLevel: 5,
          cost: (lvl) => ({moondust: 15 * (lvl + 1)}),
          icon: '⚡',
        },
      ],
      armory: [
        {
          id: 'gun_dmg', name: 'Calibrate Weapon', desc: '+1 Base Damage (Equipped)', maxLevel: 10,
          cost: (lvl) => ({moondust: 10 * (lvl + 1), alien_chitin: 5 * (lvl + 1)}),
          icon: '🎯',
        },
        {
          id: 'gun_rate', name: 'Tune Firing Pin', desc: '+5% Fire Rate (Equipped)', maxLevel: 5,
          cost: (lvl) => ({alien_chitin: 10 * (lvl + 1)}),
          icon: '🔥',
        },
        {
          id: 'gun_proj_speed', name: 'Velocity Enhancer', desc: '+10 Proj. Speed (Equipped)', maxLevel: 5,
          cost: (lvl) => ({moondust: 10 * (lvl + 1), alien_chitin: 5 * (lvl + 1)}),
          icon: '🚀',
        }
      ],
      garage: [
        {
          id: 'drone_unlock',
          name: 'Drone Bay',
          desc: 'Unlocks the first combat drone. More can be found in the field.',
          maxLevel: 1,
          cost: (lvl) => ({moondust: 150, alien_chitin: 100}),
          icon: '🤖',
        },
        {
          id: 'rover_unlock',
          name: 'Rover Payload',
          desc: 'Unlocks the rover, adding an extra projectile to your shots.',
          maxLevel: 1,
          cost: (lvl) => ({moondust: 150, plant_fiber: 100}),
          icon: '🚚',
        },
        {
          id: 'orbital_unlock',
          name: 'Orbital Cannon',
          desc: 'Unlocks orbital strikes that randomly hit the battlefield.',
          maxLevel: 1,
          cost: (lvl) => ({moondust: 250, alien_chitin: 150, plant_fiber: 150}),
          icon: '🛰️',
        }
      ]
    };
    const textures = {};
    const sprites = {
      drawPlayer: (ctx, x, y, frame, facingRight) => {
        const p = 3;
        ctx.save();
        ctx.translate(x, y);
        if (!facingRight) ctx.scale(-1, 1);
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(-2 * p, -3 * p, 4 * p, 4 * p);
        ctx.fillStyle = '#d1d5db';
        ctx.fillRect(-1.5 * p, -3 * p, 3 * p, 3 * p);
        const legOffset = (frame === 1) ? p : 0;
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(-2 * p, p, 2 * p, 3 * p);
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(legOffset, p, 2 * p, 3 * p);
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(-2.5 * p, -7 * p, 5 * p, 5 * p);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(-2 * p, -6.5 * p, 4 * p, 4 * p);
        ctx.fillStyle = '#111827';
        ctx.fillRect(-1.5 * p, -6 * p, 4 * p, 3 * p);
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(p, -2 * p, 3 * p, p);
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(2 * p, -3 * p, p, 2 * p);
        ctx.restore();
      },
      drawCharger: (ctx, x, y) => {
        const p = 4;
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = '#7f1d1d';
        ctx.fillRect(-2 * p, -1 * p, 4 * p, 3 * p);
        ctx.fillStyle = '#BE123C';
        ctx.fillRect(-1.5 * p, -1.5 * p, 3 * p, 2 * p);
        ctx.fillStyle = '#FCA5A5';
        ctx.fillRect(-1 * p, -2 * p, 2 * p, p);
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(-2.5 * p, 0, p, 2 * p);
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(1.5 * p, 0, p, 2 * p);
        ctx.restore();
      },
      drawSpitter: (ctx, x, y) => {
        const p = 3;
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = '#5b21b6';
        ctx.fillRect(-1.5 * p, -2.5 * p, 3 * p, 5 * p);
        ctx.fillStyle = '#8B5CF6';
        ctx.fillRect(-1 * p, -2 * p, 2 * p, 4 * p);
        ctx.fillStyle = '#C4B5FD';
        ctx.fillRect(-0.5 * p, -3.5 * p, p, p);
        ctx.fillStyle = '#7c3aed';
        ctx.fillRect(-2.5 * p, -1.5 * p, p, 3 * p);
        ctx.fillStyle = '#7c3aed';
        ctx.fillRect(1.5 * p, -1.5 * p, p, 3 * p);
        ctx.restore();
      },
      drawWorm: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const segmentCount = 6, baseRadius = 7, segmentOffset = 5, wiggleMagnitude = 2, wiggleSpeed = 5;
        for (let i = 0; i < segmentCount; i++) {
          const radius = baseRadius - i * 0.8;
          const offsetY = i * segmentOffset;
          const offsetX = Math.sin(animTimer * wiggleSpeed + i * 0.5) * wiggleMagnitude;
          ctx.fillStyle = `hsl(${100 - i * 5}, 70%, ${40 + i * 5}%)`;
          ctx.beginPath();
          ctx.arc(offsetX, offsetY, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = `hsl(${100 - i * 5}, 70%, ${20 + i * 5}%)`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        ctx.fillStyle = '#84cc16';
        ctx.beginPath();
        ctx.arc(Math.sin(animTimer * wiggleSpeed) * wiggleMagnitude, -baseRadius - 3, baseRadius * 1.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-3 + Math.sin(animTimer * wiggleSpeed) * wiggleMagnitude, -baseRadius - 5, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(3 + Math.sin(animTimer * wiggleSpeed) * wiggleMagnitude, -baseRadius - 5, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      },
      // New sprite for Squid alien
      drawSquid: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#6d28d9'; // Purple
        const eyeColor = '#ede9fe'; // Light purple/white
        const pupilColor = '#000'; // Black
        const tentacleColor = '#8b5cf6'; // Lighter purple

        // Body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, -10, 20, 25, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();

        // Eyes
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(-8, -15, 4, 0, Math.PI * 2); // Left eye
        ctx.arc(8, -15, 4, 0, Math.PI * 2); // Right eye
        ctx.fill();

        ctx.fillStyle = pupilColor;
        ctx.beginPath();
        ctx.arc(-8 + Math.sin(animTimer * 5), -15, 2, 0, Math.PI * 2); // Left pupil
        ctx.arc(8 + Math.sin(animTimer * 5), -15, 2, 0, Math.PI * 2); // Right pupil
        ctx.fill();

        // Tentacles (simple representation)
        ctx.strokeStyle = tentacleColor;
        ctx.lineWidth = 3;
        const tentacleWiggle = Math.sin(animTimer * 7) * 5;

        ctx.beginPath();
        ctx.moveTo(-15, 10);
        ctx.quadraticCurveTo(-20, 20 + tentacleWiggle, -10, 30);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(15, 10);
        ctx.quadraticCurveTo(20, 20 - tentacleWiggle, 10, 30);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(-5, 15);
        ctx.quadraticCurveTo(-5, 25 + tentacleWiggle, 0, 35);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(5, 15);
        ctx.quadraticCurveTo(5, 25 - tentacleWiggle, 0, 35);
        ctx.stroke();

        ctx.restore();
      },
      // New alien sprite for Ice Planet
      drawIceCrawler: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#60a5fa'; // Blue
        const legColor = '#93c5fd'; // Light blue
        const eyeColor = '#e0f2fe'; // Pale blue

        // Body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 15, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // Legs
        ctx.fillStyle = legColor;
        const legWiggle = Math.sin(animTimer * 10) * 3;
        ctx.fillRect(-12, 5 + legWiggle, 5, 8);
        ctx.fillRect(-5, 8 - legWiggle, 5, 8);
        ctx.fillRect(7, 5 + legWiggle, 5, 8);
        ctx.fillRect(0, 8 - legWiggle, 5, 8);

        // Eyes
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(-7, -5, 3, 0, Math.PI * 2);
        ctx.arc(7, -5, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },
      // New alien sprite for Ice Planet (Frost Beetle)
      drawFrostBeetle: (ctx, x, y) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#4a7090'; // Darker blue-grey
        const armorColor = '#8fa3b7'; // Lighter blue-grey
        const legColor = '#607d8b'; // Mid blue-grey

        // Body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 20, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Armor plates
        ctx.fillStyle = armorColor;
        ctx.fillRect(-15, -10, 30, 8);
        ctx.fillRect(-10, -15, 20, 8);

        // Legs (simplified)
        ctx.fillStyle = legColor;
        ctx.fillRect(-18, 5, 5, 10);
        ctx.fillRect(-8, 8, 5, 10);
        ctx.fillRect(13, 5, 5, 10);
        ctx.fillRect(3, 8, 5, 10);

        ctx.restore();
      },
      // New alien sprite for Ice Planet (Snow Serpent)
      drawSnowSerpent: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#add8e6'; // Light blue
        const eyeColor = '#000';

        const segmentCount = 5;
        const baseRadius = 8;
        const wiggle = Math.sin(animTimer * 8) * 4;

        for (let i = 0; i < segmentCount; i++) {
          const radius = baseRadius - i;
          const offsetX = Math.sin(animTimer * 5 + i * 0.5) * wiggle;
          const offsetY = i * 10;
          ctx.fillStyle = `rgba(${parseInt(bodyColor.slice(1, 3), 16)}, ${parseInt(bodyColor.slice(3, 5), 16)}, ${parseInt(bodyColor.slice(5, 7), 16)}, ${1 - i * 0.15})`;
          ctx.beginPath();
          ctx.arc(offsetX, offsetY, radius, 0, Math.PI * 2);
          ctx.fill();
        }

        // Head
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.arc(0, -baseRadius - 5, baseRadius * 1.2, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(-5, -baseRadius - 7, 2, 0, Math.PI * 2);
        ctx.arc(5, -baseRadius - 7, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },

      // New alien sprite for Red Planet
      drawSandBeast: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#b45309'; // Dark orange
        const shellColor = '#f97316'; // Bright orange
        const clawColor = '#dc2626'; // Red

        // Body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(-20, -10, 40, 20);

        // Shell
        ctx.fillStyle = shellColor;
        ctx.beginPath();
        ctx.arc(0, -10, 25, Math.PI, Math.PI * 2);
        ctx.fill();

        // Claws
        const clawAngle = Math.sin(animTimer * 5) * 0.2;
        ctx.fillStyle = clawColor;
        ctx.beginPath();
        ctx.moveTo(-20, 0);
        ctx.lineTo(-35 * Math.cos(clawAngle), -10 - 35 * Math.sin(clawAngle));
        ctx.lineTo(-20, -10);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(20, 0);
        ctx.lineTo(35 * Math.cos(clawAngle), -10 + 35 * Math.sin(clawAngle));
        ctx.lineTo(20, -10);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      },
      // New alien sprite for Red Planet (Scorpion Drone)
      drawScorpionDrone: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#57534e'; // Stone gray
        const accentColor = '#f97316'; // Orange accent
        const wheelColor = '#292524'; // Dark gray

        // Body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(-15, -8, 30, 16);

        // Wheels
        ctx.fillStyle = wheelColor;
        ctx.beginPath();
        ctx.arc(-10, 8, 4, 0, Math.PI * 2);
        ctx.arc(10, 8, 4, 0, Math.PI * 2);
        ctx.fill();

        // Tail (simplified)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.moveTo(15, 0);
        ctx.lineTo(25, -10);
        ctx.lineTo(20, 0);
        ctx.lineTo(25, 10);
        ctx.closePath();
        ctx.fill();

        // Pincers
        const pincerAngle = Math.sin(animTimer * 7) * 0.1;
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-15, -5);
        ctx.lineTo(-25, -10 - pincerAngle * 10);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-15, 5);
        ctx.lineTo(-25, 10 + pincerAngle * 10);
        ctx.stroke();

        ctx.restore();
      },
      // New alien sprite for Red Planet (Heat Worm)
      drawHeatWorm: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#a83c07'; // Deep orange
        const glowColor = '#f97316'; // Bright orange
        const eyeColor = '#000';

        const segmentCount = 4;
        const baseRadius = 10;
        const wiggle = Math.sin(animTimer * 6) * 3;

        for (let i = 0; i < segmentCount; i++) {
          const radius = baseRadius - i * 1.5;
          const offsetX = Math.sin(animTimer * 4 + i * 0.6) * wiggle;
          const offsetY = i * 12;
          ctx.fillStyle = `rgba(${parseInt(bodyColor.slice(1, 3), 16)}, ${parseInt(bodyColor.slice(3, 5), 16)}, ${parseInt(bodyColor.slice(5, 7), 16)}, ${1 - i * 0.2})`;
          ctx.beginPath();
          ctx.arc(offsetX, offsetY, radius, 0, Math.PI * 2);
          ctx.fill();
          // Glowing effect
          ctx.fillStyle = `rgba(${parseInt(glowColor.slice(1, 3), 16)}, ${parseInt(glowColor.slice(3, 5), 16)}, ${parseInt(glowColor.slice(5, 7), 16)}, ${0.7 - i * 0.15})`;
          ctx.beginPath();
          ctx.arc(offsetX, offsetY, radius * 0.7, 0, Math.PI * 2);
          ctx.fill();
        }

        // Head
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.arc(0, -baseRadius - 7, baseRadius * 1.3, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(-6, -baseRadius - 9, 2.5, 0, Math.PI * 2);
        ctx.arc(6, -baseRadius - 9, 2.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },

      // New alien sprite for Beachy Planet
      drawCrabMutant: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bodyColor = '#ef4444'; // Red
        const clawColor = '#facc15'; // Yellow
        const eyeColor = '#f97316'; // Orange

        // Body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 20, 15, 0, 0, Math.PI * 2);
        ctx.fill();

        // Legs (simple)
        ctx.fillStyle = bodyColor;
        ctx.fillRect(-15, 10, 5, 10);
        ctx.fillRect(10, 10, 5, 10);

        // Claws
        const clawOpen = Math.sin(animTimer * 5) * 0.1 + 0.1;
        ctx.fillStyle = clawColor;
        ctx.beginPath();
        ctx.moveTo(-20, -5);
        ctx.lineTo(-30, -15 - clawOpen * 20);
        ctx.lineTo(-25, -10);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(20, -5);
        ctx.lineTo(30, -15 - clawOpen * 20);
        ctx.lineTo(25, -10);
        ctx.closePath();
        ctx.fill();

        // Eyes on stalks
        ctx.fillStyle = eyeColor;
        ctx.fillRect(-10, -25, 3, 10);
        ctx.fillRect(7, -25, 3, 10);
        ctx.beginPath();
        ctx.arc(-8, -27, 4, 0, Math.PI * 2);
        ctx.arc(8, -27, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },
      // New alien sprite for Beachy Planet (Jellyfish)
      drawJellyfish: (ctx, x, y, animTimer) => {
        ctx.save();
        ctx.translate(x, y);
        const bellColor = '#a855f7'; // Purple
        const tentacleColor = '#c084fc'; // Lighter purple
        const eyeColor = '#000';

        // Bell
        ctx.fillStyle = bellColor;
        ctx.beginPath();
        ctx.arc(0, -10, 15, Math.PI, 0, true);
        ctx.bezierCurveTo(15, -10, 10, 5, 0, 10);
        ctx.bezierCurveTo(-10, 5, -15, -10, -15, -10);
        ctx.fill();

        // Tentacles
        ctx.strokeStyle = tentacleColor;
        ctx.lineWidth = 2;
        const tentacleWiggle = Math.sin(animTimer * 6) * 5;
        ctx.beginPath();
        ctx.moveTo(-8, 8);
        ctx.lineTo(-12, 20 + tentacleWiggle);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(8, 8);
        ctx.lineTo(12, 20 - tentacleWiggle);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(0, 25 + tentacleWiggle * 0.5);
        ctx.stroke();

        // Eyes
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(-5, -15, 2, 0, Math.PI * 2);
        ctx.arc(5, -15, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },
      // New alien sprite for Beachy Planet (Piranha Swarm) - representing one piranha
      drawPiranha: (ctx, x, y, angle) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        const bodyColor = '#dc2626'; // Red
        const finColor = '#facc15'; // Yellow
        const eyeColor = '#000';

        // Body
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(10, -5);
        ctx.lineTo(10, 5);
        ctx.closePath();
        ctx.fill();

        // Tail
        ctx.fillStyle = finColor;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(15, -7);
        ctx.lineTo(15, 7);
        ctx.closePath();
        ctx.fill();

        // Eye
        ctx.fillStyle = eyeColor;
        ctx.beginPath();
        ctx.arc(-5, -2, 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },
      drawDrone: (ctx, x, y) => {
        ctx.fillStyle = '#a1a1aa';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#f97316';
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      },
      drawRover: (ctx, x, y) => {
        ctx.fillStyle = '#78716c'; // Stone color
        ctx.fillRect(x - 10, y - 6, 20, 12);
        ctx.fillStyle = '#44403c'; // Darker for wheels
        ctx.fillRect(x - 8, y - 8, 4, 16);
        ctx.fillRect(x + 4, y - 8, 4, 16);
        ctx.fillStyle = '#f97316'; // Orange light
        ctx.fillRect(x - 1, y - 1, 2, 2);
      },
      drawMissile: (ctx, x, y, angle) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.fillStyle = '#fefce8';
        ctx.fillRect(-10, -2, 20, 4);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(6, -3, 8, 6);
        ctx.restore();
      },
      drawTerminal: (ctx, x, y, width, height, animTimer) => {
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(x - width / 2 + 5, y - height / 2 + 5, width - 10, height - 10);
        const scanLineY = (y - height / 2 + 10) + ((animTimer * 20) % (height * 0.5));
        ctx.fillStyle = '#f97316';
        ctx.fillRect(x - width / 2 + 10, scanLineY, width - 20, 2);
        ctx.fillStyle = '#334155';
        ctx.fillRect(x - width / 2 + 10, y - height / 2 + height * 0.7, width - 20, height * 0.2);
      },
      drawWorkshop: (ctx, x, y, width, height) => {
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x - width / 2 + 5, y - height / 2 + 5, width - 10, height - 10);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(x - width / 2 + 10, y - height / 2 + 10, 5, 5);
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(x - width / 2 + 20, y - height / 2 + 20, 20, 5);
        ctx.fillRect(x - width / 2 + 45, y - height / 2 + 30, 5, 15);
      },
      drawArmory: (ctx, x, y, width, height) => {
        ctx.fillStyle = '#334155';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x - width / 2 + 5, y - height / 2, width - 10, height - 5);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(x - width / 2 + 10, y - height / 2 + 10, width - 20, 5);
        ctx.fillRect(x - width / 2 + 10, y - height / 2 + 20, width - 20, 5);
      },
      drawGarage: (ctx, x, y, width, height) => {
        ctx.fillStyle = '#4a044e';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x - width / 2 + 5, y + height / 2 - 10, width - 10, 5);
        ctx.fillStyle = '#a21caf';
        ctx.fillRect(x - width / 2 + 15, y - height / 2 + 15, width - 30, 10);
        ctx.fillRect(x - width / 2 + 15, y - height / 2 + 30, width - 30, 10);
      },
      drawBed: (ctx, x, y, width, height) => {
        ctx.fillStyle = '#334155';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x - width / 2 + 5, y - height / 2 + 5, width - 10, height - 10);
        ctx.fillStyle = '#c2410c';
        ctx.fillRect(x - width / 2 + 10, y - height / 2 + 10, width - 20, height - 25);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(x - width / 2 + 15, y - height / 2 + 15, 20, 10);
      },
      drawKitchen: (ctx, x, y, width, height) => {
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x - width / 2 + 5, y - height / 2 + 5, width - 10, height - 10);
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(x - width / 2 + 10, y - height / 2 + 10, width - 20, 20);
        ctx.fillStyle = '#f97316';
        ctx.fillRect(x - width / 2 + 15, y - height / 2 + 15, 5, 5);
      },
      drawTableAndChairs: (ctx, x, y) => {
        ctx.fillStyle = '#78350f';
        ctx.fillRect(x - 30, y - 15, 60, 30);
        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(x - 25, y - 10, 50, 20);
        ctx.fillStyle = '#374151';
        ctx.fillRect(x - 50, y - 10, 15, 20);
        ctx.fillStyle = '#111827';
        ctx.fillRect(x - 48, y - 8, 11, 16);
        ctx.fillStyle = '#374151';
        ctx.fillRect(x + 35, y - 10, 15, 20);
        ctx.fillStyle = '#111827';
        ctx.fillRect(x + 37, y - 8, 11, 16);
      },
      drawDatabase: (ctx, x, y, width, height) => {
        ctx.fillStyle = '#607d8b';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#37474f';
        ctx.fillRect(x - width / 2 + 5, y - height / 2 + 5, width - 10, height - 10);
        ctx.fillStyle = '#4fc3f7';
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(x - width / 2 + 10, y - height / 2 + 15 + i * 15, width - 20, 2);
        }
      },
      drawInfirmary: (ctx, x, y, width, height) => {
        ctx.fillStyle = '#7f1d1d';
        ctx.fillRect(x - width / 2, y - height / 2, width, height);
        ctx.fillStyle = '#b91c1c';
        ctx.fillRect(x - 15, y - 5, 30, 10);
        ctx.fillRect(x - 5, y - 15, 10, 30);
        ctx.fillStyle = '#eab308';
        ctx.beginPath();
        ctx.arc(x - width / 2 + 10, y - height / 2 + 10, 5, 0, Math.PI * 2);
        ctx.fill();
      },
      drawStarbase: (ctx, width, height, animTimer) => {
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, width, height);
        stars.forEach(star => {
          const opacity = star.size / 2.0;
          ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
          ctx.fill();
        });
        const room = starbaseHub.rect;
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(room.x, room.y, room.width, room.height);
        ctx.fillStyle = textures.starbase_floor;
        ctx.fillRect(room.x, room.y, room.width, room.height);
        ctx.fillStyle = '#1a202c';
        ctx.fillRect(room.x - 10, room.y - 10, room.width + 20, 10);
        ctx.fillRect(room.x - 10, room.y + room.height, room.width + 20, 10);
        ctx.fillRect(room.x - 10, room.y - 10, 10, room.height + 20);
        ctx.fillRect(room.x + room.width, room.y - 10, 10, room.height + 20);
        ctx.fillStyle = '#0f172a';
        for (let i = room.x; i < room.x + room.width; i += 80) {
          ctx.fillRect(i, room.y - 10, 20, 10);
          ctx.fillRect(i + 30, room.y + room.height, 20, 10);
        }
      },
      drawPlanetFloor: (ctx, width, height) => {
        if (activeMap && activeMap.id === 'coral_beach') {
          // Draw blue water (bottom 1/5th)
          const waterHeight = canvas.height / 5;
          ctx.fillStyle = '#3B82F6'; // Blue for water
          ctx.fillRect(0, canvas.height - waterHeight, canvas.width, waterHeight);
          // Draw white sand (top 4/5th)
          ctx.fillStyle = '#F3F4F6'; // White for sand
          ctx.fillRect(0, 0, canvas.width, canvas.height - waterHeight);
        } else if (activeMap) {
          ctx.fillStyle = textures[activeMap.id];
          ctx.fillRect(0, 0, width, height);
        } else {
          ctx.fillStyle = '#000'; // Fallback
          ctx.fillRect(0, 0, width, height);
        }
      },
      drawRock: (ctx, x, y, subType) => {
        ctx.fillStyle = '#52525b';
        ctx.beginPath();
        if (subType === 1) {
          ctx.moveTo(x, y);
          ctx.lineTo(x + 20, y - 10);
          ctx.lineTo(x + 30, y + 15);
          ctx.lineTo(x + 10, y + 25);
          ctx.lineTo(x - 15, y + 10);
        } else {
          ctx.moveTo(x, y);
          ctx.lineTo(x + 15, y - 15);
          ctx.lineTo(x + 25, y + 5);
          ctx.lineTo(x - 5, y + 20);
        }
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#a1a1aa';
        ctx.beginPath();
        if (subType === 1) {
          ctx.moveTo(x, y);
          ctx.lineTo(x + 20, y - 10);
          ctx.lineTo(x - 5, y - 5);
        } else {
          ctx.moveTo(x, y);
          ctx.lineTo(x + 15, y - 15);
          ctx.lineTo(x + 5, y - 5);
        }
        ctx.closePath();
        ctx.fill();
      },
      // New terrain for Red Planet
      drawLargeRock: (ctx, x, y) => {
        ctx.fillStyle = '#7c2d12'; // Darker red-brown
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 40, y - 20);
        ctx.lineTo(x + 60, y + 20);
        ctx.lineTo(x + 10, y + 40);
        ctx.lineTo(x - 30, y + 15);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#9a3412'; // Lighter red-brown for highlight
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + 30, y - 15);
        ctx.lineTo(x + 5, y - 5);
        ctx.closePath();
        ctx.fill();
      },
      drawDunes: (ctx, x, y, animTimer) => {
        ctx.fillStyle = '#cc5a2e'; // Sandy orange
        ctx.beginPath();
        ctx.arc(x, y + 10, 30, 0, Math.PI, true); // Main dune curve
        ctx.lineTo(x + 30, y + 30);
        ctx.lineTo(x - 30, y + 30);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#d97706'; // Darker shade for shadow
        ctx.beginPath();
        ctx.arc(x - 10, y + 5, 20, 0, Math.PI, false); // Smaller dune detail
        ctx.fill();
      },
      drawPlant: (ctx, x, y, subType) => {
        ctx.fillStyle = subType === 1 ? '#166534' : '#15803d';
        ctx.strokeStyle = '#14532d';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        if (subType < 3) {
          ctx.lineTo(x, y - 20);
          ctx.stroke();
          ctx.fillStyle = subType === 1 ? '#4ade80' : '#86efac';
          ctx.beginPath();
          ctx.arc(x, y - 25, 10, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.bezierCurveTo(x - 10, y - 15, x + 10, y - 25, x, y - 30);
          ctx.stroke();
          ctx.fillStyle = subType === 3 ? '#22c55e' : '#10b981';
          ctx.beginPath();
          ctx.fillRect(x - 4, y - 35, 8, 8);
        }
        ctx.closePath();
      },
      drawShrub: (ctx, x, y) => {
        ctx.fillStyle = '#4d7c0f';
        ctx.beginPath();
        ctx.arc(x, y, 8, Math.PI, 0);
        ctx.fill();
        ctx.fillStyle = '#a3e635';
        ctx.beginPath();
        ctx.arc(x - 4, y, 4, Math.PI, 0);
        ctx.arc(x + 4, y, 4, Math.PI, 0);
        ctx.fill();
      },
      // New terrain for Icy Planet
      drawIceCave: (ctx, x, y) => {
        ctx.fillStyle = '#4F7C8A'; // Darker icy blue
        ctx.beginPath();
        ctx.arc(x, y, 30, Math.PI, 0, true); // Top of cave entrance
        ctx.lineTo(x + 30, y + 40);
        ctx.lineTo(x - 30, y + 40);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = '#A7D9ED'; // Lighter icy blue for highlight
        ctx.beginPath();
        ctx.moveTo(x - 20, y);
        ctx.lineTo(x - 10, y - 20);
        ctx.lineTo(x + 10, y - 20);
        ctx.lineTo(x + 20, y);
        ctx.closePath();
        ctx.fill();
      },
      drawIcePatch: (ctx, x, y) => {
        ctx.fillStyle = '#BEE3F8'; // Pale blue-white for ice
        ctx.beginPath();
        ctx.ellipse(x, y, 35, 15, Math.random() * Math.PI, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#60A5FA'; // Blue outline
        ctx.lineWidth = 2;
        ctx.stroke();
      },
      // New terrain for Beachy Planet
      drawPalmTree: (ctx, x, y) => {
        ctx.fillStyle = '#8B4513'; // Brown trunk
        ctx.fillRect(x - 5, y - 40, 10, 50);
        ctx.fillStyle = '#22C55E'; // Green leaves
        ctx.beginPath();
        ctx.moveTo(x, y - 40);
        ctx.lineTo(x - 20, y - 60);
        ctx.lineTo(x - 10, y - 45);
        ctx.lineTo(x - 30, y - 30);
        ctx.lineTo(x, y - 50);
        ctx.lineTo(x + 30, y - 30);
        ctx.lineTo(x + 10, y - 45);
        ctx.lineTo(x + 20, y - 60);
        ctx.closePath();
        ctx.fill();
      },
      drawCoralFormation: (ctx, x, y) => {
        ctx.fillStyle = '#F87171'; // Red-orange coral
        ctx.beginPath();
        ctx.arc(x, y, 15, 0, Math.PI * 2);
        ctx.arc(x - 10, y + 10, 10, 0, Math.PI * 2);
        ctx.arc(x + 10, y + 8, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#60A5FA'; // Blue highlights
        ctx.beginPath();
        ctx.arc(x - 5, y - 5, 5, 0, Math.PI * 2);
        ctx.fill();
      },
      drawCrystalResource: (ctx, x, y, radius, color) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y - radius);
        ctx.lineTo(x + radius, y);
        ctx.lineTo(x + radius / 2, y + radius);
        ctx.lineTo(x - radius / 2, y + radius);
        ctx.lineTo(x - radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = `rgba(255, 255, 255, 0.5)`;
        ctx.beginPath();
        ctx.moveTo(x, y - radius);
        ctx.lineTo(x + radius * 0.4, y - radius * 0.2);
        ctx.lineTo(x, y - radius * 0.5);
        ctx.closePath();
        ctx.fill();
      },
      drawMushroomResource: (ctx, x, y, radius, color) => {
        ctx.fillStyle = '#964B00';
        ctx.fillRect(x - radius * 0.3, y, radius * 0.6, radius * 1.2);
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, Math.PI, Math.PI * 2, false);
        ctx.fill();
        ctx.fillStyle = '#f0f0f0';
        ctx.beginPath();
        ctx.arc(x - radius * 0.4, y - radius * 0.4, radius * 0.15, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.3, y - radius * 0.5, radius * 0.1, 0, Math.PI * 2);
        ctx.fill();
      },
      drawChitinShard: (ctx, x, y, color) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x + 7, y + 2);
        ctx.lineTo(x - 2, y + 8);
        ctx.lineTo(x - 7, y - 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
        ctx.beginPath();
        ctx.moveTo(x, y - 8);
        ctx.lineTo(x + 2, y - 5);
        ctx.lineTo(x, y - 6);
        ctx.closePath();
        ctx.fill();
      },
      // New sprite for Goop material drop
      drawGoop: (ctx, x, y, color) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 7, 0, Math.PI * 2);
        ctx.ellipse(x - 5, y + 5, 5, 3, 0, 0, Math.PI * 2);
        ctx.ellipse(x + 5, y + 4, 4, 2, 0, 0, Math.PI * 2);
        ctx.fill();
      },
      // New sprite for Frost Shard material drop
      drawFrostShard: (ctx, x, y, color) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y - 7);
        ctx.lineTo(x + 6, y);
        ctx.lineTo(x, y + 7);
        ctx.lineTo(x - 6, y);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = `rgba(255, 255, 255, 0.5)`;
        ctx.beginPath();
        ctx.moveTo(x, y - 7);
        ctx.lineTo(x + 3, y - 3);
        ctx.lineTo(x, y - 4);
        ctx.closePath();
        ctx.fill();
      },
      // New sprite for Magma Rock material drop
      drawMagmaRock: (ctx, x, y, color) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ef4444'; // Red hot spot
        ctx.beginPath();
        ctx.arc(x + 3, y - 3, 3, 0, Math.PI * 2);
        ctx.fill();
      },
      // New sprite for Fin material drop
      drawFin: (ctx, x, y, color) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x - 8, y);
        ctx.lineTo(x + 8, y - 5);
        ctx.lineTo(x + 8, y + 5);
        ctx.closePath();
        ctx.fill();
      },
      drawResourceNode: (ctx, node) => {
        if (node.material === 'plant_fiber' && activeMap && activeMap.id === 'verdant_prime') {
          sprites.drawMushroomResource(ctx, node.x, node.y, node.radius, materials[node.material].color);
        } else if (node.material === 'moondust') {
          sprites.drawCrystalResource(ctx, node.x, node.y, node.radius, materials[node.material].color);
        } else if (node.material === 'ice_crystal') { // Draw for new ice_crystal
          sprites.drawCrystalResource(ctx, node.x, node.y, node.radius, materials[node.material].color);
        } else if (node.material === 'seaweed') { // Draw for new seaweed
          sprites.drawMushroomResource(ctx, node.x, node.y, node.radius, materials[node.material].color); // Using mushroom for now
        } else {
          ctx.fillStyle = materials[node.material].color;
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
          ctx.fill();
        }
        const hp = node.health / node.maxHealth;
        if (hp < 1) {
          ctx.fillStyle = '#4B5563';
          ctx.fillRect(node.x - node.radius, node.y - node.radius - 8, node.radius * 2, 4);
          ctx.fillStyle = '#FBBF24';
          ctx.fillRect(node.x - node.radius, node.y - node.radius - 8, node.radius * 2 * hp, 4);
        }
      },
      drawMaterial: (ctx, x, y, type) => {
        if (type === 'alien_chitin') {
          sprites.drawChitinShard(ctx, x, y, materials[type].color);
        } else if (type === 'goop') { // New drawing for Goop
          sprites.drawGoop(ctx, x, y, materials[type].color);
        } else if (type === 'ice_crystal') {
          sprites.drawCrystalResource(ctx, x, y, 7, materials[type].color);
        } else if (type === 'seaweed') {
          sprites.drawMushroomResource(ctx, x, y, 7, materials[type].color);
        } else if (type === 'frost_shard') { // New drawing for frost_shard
          sprites.drawFrostShard(ctx, x, y, materials[type].color);
        } else if (type === 'magma_rock') { // New drawing for magma_rock
          sprites.drawMagmaRock(ctx, x, y, materials[type].color);
        } else if (type === 'fin') { // New drawing for fin
          sprites.drawFin(ctx, x, y, materials[type].color);
        } else {
          ctx.fillStyle = materials[type].color;
          ctx.fillRect(x - 5, y - 5, 10, 10);
          ctx.strokeStyle = '#111827';
          ctx.lineWidth = 2;
          ctx.strokeRect(x - 5, y - 5, 10, 10);
        }
      },
    };

    const alienData = {
      'charger': {
        name: 'Charger',
        health: 10,
        xpValue: 20,
        drops: [{material: 'alien_chitin', chance: 0.5, quantity: 1}],
        sprite: sprites.drawCharger,
        speed: 75,
        attackRadius: 64,
        attackDamage: 10,
        state: 'moving',
        chargeTime: 1.5,
        chargeTimer: 0
      },
      'spitter': {
        name: 'Spitter', health: 20, xpValue: 30,
        drops: [{material: 'alien_chitin', chance: 0.2, quantity: 1}, {
          material: 'plant_fiber',
          chance: 0.1,
          quantity: 1
        }],
        sprite: sprites.drawSpitter, speed: 50, preferredDist: 250, fireCooldown: 1, fireRate: 0.5
      },
      'worm': {
        name: 'Rock Worm', health: 30, xpValue: 40,
        drops: [{material: 'moondust', chance: 0.3, quantity: 1}, {material: 'alien_chitin', chance: 0.1, quantity: 1}],
        sprite: sprites.drawWorm, speed: 40, attackDamage: 15, attackCooldown: 1, attackRate: 1
      },
      'squid': {
        name: 'Acid Squid', health: 25, xpValue: 35,
        drops: [{material: 'goop', chance: 0.7, quantity: 1}],
        sprite: sprites.drawSquid, speed: 60, attackDamage: 8, attackCooldown: 1.5, attackRate: 1 / 1.5
      },
      'ice_crawler': {
        name: 'Ice Crawler', health: 15, xpValue: 25,
        drops: [{material: 'ice_crystal', chance: 0.8, quantity: 1}],
        sprite: sprites.drawIceCrawler, speed: 80, attackDamage: 7, attackCooldown: 1, attackRate: 1
      },
      'frost_beetle': { // New alien for Glacial Wastes
        name: 'Frost Beetle', health: 50, xpValue: 60,
        drops: [{material: 'frost_shard', chance: 0.9, quantity: 1}],
        sprite: sprites.drawFrostBeetle, speed: 30, attackDamage: 15, attackCooldown: 2.5, attackRate: 1 / 2.5
      },
      'snow_serpent': { // New alien for Glacial Wastes
        name: 'Snow Serpent', health: 20, xpValue: 30,
        drops: [{material: 'frost_shard', chance: 0.7, quantity: 1}],
        sprite: sprites.drawSnowSerpent, speed: 70, attackDamage: 10, attackCooldown: 1, attackRate: 1 // Melee for now, could be ranged
      },
      'sand_beast': {
        name: 'Sand Beast', health: 40, xpValue: 50,
        drops: [{material: 'moondust', chance: 0.6, quantity: 2}, {material: 'alien_chitin', chance: 0.3, quantity: 1}],
        sprite: sprites.drawSandBeast, speed: 45, attackDamage: 20, attackCooldown: 2, attackRate: 1 / 2
      },
      'scorpion_drone': { // New alien for Crimson Sands
        name: 'Scorpion Drone', health: 20, xpValue: 30,
        drops: [{material: 'magma_rock', chance: 0.7, quantity: 1}],
        sprite: sprites.drawScorpionDrone, speed: 90, attackDamage: 8, attackCooldown: 0.7, attackRate: 1 / 0.7
      },
      'heat_worm': { // New alien for Crimson Sands
        name: 'Heat Worm', health: 60, xpValue: 70,
        drops: [{material: 'magma_rock', chance: 0.8, quantity: 2}],
        sprite: sprites.drawHeatWorm, speed: 20, attackDamage: 25, attackCooldown: 3, attackRate: 1 / 3
      },
      'crab_mutant': {
        name: 'Crab Mutant', health: 35, xpValue: 45,
        drops: [{material: 'seaweed', chance: 0.7, quantity: 1}, {material: 'alien_chitin', chance: 0.2, quantity: 1}],
        sprite: sprites.drawCrabMutant, speed: 55, attackDamage: 12, attackCooldown: 1.2, attackRate: 1 / 1.2
      },
      'jellyfish': { // New alien for Azure Coast
        name: 'Stinging Jellyfish', health: 10, xpValue: 15,
        drops: [{material: 'goop', chance: 0.6, quantity: 1}],
        sprite: sprites.drawJellyfish, speed: 40, attackDamage: 5, attackCooldown: 0.5, attackRate: 1 / 0.5
      },
      'piranha_swarm': { // New alien for Azure Coast - represented as a single entity for now
        name: 'Piranha Swarm', health: 70, xpValue: 80,
        drops: [{material: 'fin', chance: 0.9, quantity: 1}],
        sprite: (ctx, x, y, animTimer) => { // Custom drawing for swarm
          const numPiranhas = 5;
          const spreadRadius = 15;
          for (let i = 0; i < numPiranhas; i++) {
            const angle = (Math.PI * 2 / numPiranhas) * i + animTimer;
            const px = x + Math.cos(angle) * spreadRadius;
            const py = y + Math.sin(angle) * spreadRadius;
            sprites.drawPiranha(ctx, px, py, angle + Math.PI / 2); // Rotate piranha to face outwards
          }
        },
        speed: 100, attackDamage: 30, attackCooldown: 1, attackRate: 1
      },
    };

    // Define which aliens spawn on which map
    const mapToAlienTypes = {
      'planet_v2': ['charger', 'spitter', 'worm', 'squid'],
      'cratered_moon': ['charger', 'worm'],
      'verdant_prime': ['spitter', 'squid'],
      'icy_planet': ['ice_crawler', 'frost_beetle', 'snow_serpent'], // Exclusive to icy planet
      'red_planet': ['sand_beast', 'scorpion_drone', 'heat_worm'], // Exclusive to red planet
      'coral_beach': ['crab_mutant', 'jellyfish', 'piranha_swarm'] // Exclusive to coral beach
    };

    function setupStars(count = 100) {
      stars.length = 0;
      const gameContainer = document.getElementById('game-container');
      if (!gameContainer) return;
      const rect = gameContainer.getBoundingClientRect();
      for (let i = 0; i < count; i++) {
        stars.push({
          x: Math.random() * rect.width,
          y: Math.random() * rect.height,
          size: Math.random() * 1.5 + 0.5,
          speed: (Math.random() * 15 + 5)
        });
      }
    }

    function updateStars(deltaTime) {
      stars.forEach(star => {
        star.x -= star.speed * deltaTime;
        if (star.x < 0) {
          star.x = canvas.width;
          star.y = Math.random() * canvas.height;
        }
      });
    }

    function setCanvasDimensions() {
      const rect = document.getElementById('game-container').getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      // Adjust Starbase Hub rect to be a fixed portion of the canvas, ensuring it's not too small or large
      // For now, let's keep it relative but ensure its center is more stable.
      // Starbase hub boundaries
      starbaseHub.rect.x = canvas.width * 0.2;
      starbaseHub.rect.y = canvas.height * 0.1;
      starbaseHub.rect.width = canvas.width * 0.6;
      starbaseHub.rect.height = canvas.height * 0.8;

      // Recalculate interactable positions based on the new hub dimensions
      const room = starbaseHub.rect;
      starbaseHub.terminal.x = room.x + room.width / 2;
      starbaseHub.terminal.y = room.y + 50;
      starbaseHub.workshop.x = room.x + 60;
      starbaseHub.workshop.y = room.y + room.height / 2 + 20;
      starbaseHub.armory.x = room.x + room.width - 50;
      starbaseHub.armory.y = room.y + room.height / 2 + 20;
      starbaseHub.garage.x = room.x + room.width / 2;
      starbaseHub.garage.y = room.y + room.height - 50;
      starbaseHub.database.x = room.x + 80;
      starbaseHub.database.y = room.y + room.height - 50;
      starbaseHub.table.x = room.x + room.width - 120;
      starbaseHub.table.y = room.y + room.height - 50;
      starbaseHub.bed.x = room.x + 70;
      starbaseHub.bed.y = room.y + 50;
      starbaseHub.kitchen.x = room.x + room.width - 60;
      starbaseHub.kitchen.y = room.y + 50;
      starbaseHub.infirmary.x = room.x + room.width - 150;
      starbaseHub.infirmary.y = room.y + 50;
      starbaseHub.interactables = [starbaseHub.terminal, starbaseHub.workshop, starbaseHub.armory, starbaseHub.garage, starbaseHub.database, starbaseHub.infirmary, starbaseHub.bed, starbaseHub.kitchen];
      setupStars();
    }

    function createTextures() {
      function createPattern(baseColor, detailColors, detailCount = 30, detailSize = 2) {
        const tex = document.createElement('canvas');
        tex.width = 64;
        tex.height = 64;
        const texCtx = tex.getContext('2d');
        texCtx.fillStyle = baseColor;
        texCtx.fillRect(0, 0, 64, 64);
        for (let i = 0; i < detailCount; i++) {
          texCtx.fillStyle = detailColors[Math.floor(Math.random() * detailColors.length)];
          texCtx.fillRect(Math.random() * 64, Math.random() * 64, detailSize, detailSize);
        }
        return ctx.createPattern(tex, 'repeat');
      }

      textures.starbase_floor = createPattern('#1e293b', ['#334155', '#475569'], 20, 4);
      textures.planet_v2 = createPattern('#2d232e', ['#3d303f', '#1e1a1f'], 50);
      textures.cratered_moon = createPattern('#47475a', ['#5c5c70', '#3e3e4d'], 50);
      textures.verdant_prime = createPattern('#2a3d34', ['#3a5447', '#1f2e26'], 50);
      textures.icy_planet = createPattern('#1a3240', ['#2a4b5d', '#0f1e29'], 50); // New texture
      textures.red_planet = createPattern('#5c200c', ['#7d2e13', '#4a1708'], 50); // New texture
      // textures.coral_beach is now handled directly in drawPlanetFloor for distinct sand/water layers
    }

    function showOverlay(overlayId, content) {
      document.querySelectorAll('.overlay').forEach(o => o.classList.add('overlay-hidden'));
      const el = document.getElementById(overlayId);
      if (el) {
        if (content) el.innerHTML = content;
        el.classList.remove('overlay-hidden');
      }
    }

    function showMessageBox(message) {
      const messageBox = document.getElementById('messageBox');
      document.getElementById('messageBoxText').textContent = message;
      messageBox.style.display = 'block';
    }

    function handleInteraction(id) {
      if (id === 'deploy') {
        showMapSelection();
      } else if (id === 'workshop' || id === 'armory' || id === 'garage') {
        openStationMenu(id);
      } else if (id === 'database') {
        showDatabase();
      } else if (id === 'infirmary') {
        useInfirmary();
      } else if (id === 'bed') {
        useBed();
      } else {
        console.log(`Interacted with ${id}`);
      }
    }

    function showDatabase() {
      gameState = 'paused';
      let databaseHTML = `<h1 class="text-4xl mb-8 text-cyan-300">Alien Database</h1><div class="flex flex-col items-center w-full max-h-[80vh] overflow-y-auto">`;

      for (const key in alienData) {
        const data = alienData[key];
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 60;
        tempCanvas.height = 60;
        const tempCtx = tempCanvas.getContext('2d');
        // Draw sprite on a temporary canvas to get its image data
        // Need to pass animTimer for worm, squid, ice_crawler, snow_serpent, sand_beast, heat_worm, crab_mutant, jellyfish, piranha_swarm
        const animSpriteTypes = ['worm', 'squid', 'ice_crawler', 'snow_serpent', 'sand_beast', 'heat_worm', 'crab_mutant', 'jellyfish', 'piranha_swarm'];
        if (animSpriteTypes.includes(key)) {
          data.sprite(tempCtx, 30, 30, globalAnimTimer);
        } else {
          data.sprite(tempCtx, 30, 30);
        }
        const iconSrc = tempCanvas.toDataURL();

        let dropsHTML = data.drops.map(d => `<p class="card-desc ml-4">- ${d.quantity} ${materials[d.material].name} (${d.chance * 100}%)</p>`).join('');
        databaseHTML += `
                    <div class="database-entry">
                        <div class="database-entry-icon">
                            <img src="${iconSrc}" alt="${data.name} icon" class="w-full h-full object-contain" />
                        </div>
                        <div class="database-entry-details">
                            <h3 class="card-title text-2xl">${data.name}</h3>
                            <p class="card-desc">Known Health: ${data.health} HP</p>
                            <p class="card-desc">Known Drops:</p>
                            ${dropsHTML}
                        </div>
                    </div>
                `;
      }
      databaseHTML += `</div><button onclick="window.closeDatabase()" class="game-button mt-8 text-sm px-6 py-3">Close Database</button>`;
      showOverlay('databaseScreen', databaseHTML);
    }

    window.closeDatabase = () => {
      showOverlay(null);
      gameState = 'starbase_hub';
    }

    function useBed() {
      if (player.health < player.maxHealth) {
        player.health = player.maxHealth;
        player.daysPassed++;
        showMessageBox("You slept and feel fully rested! Day " + player.daysPassed);
        drawHUD();
      } else {
        showMessageBox("You're not tired. Health is already full!");
      }
    }

    const INFIRMARY_HEAL_COST = {plant_fiber: 25};

    function useInfirmary() {
      const currentTime = performance.now() / 1000;
      const cooldownDuration = 10;
      if (currentTime - player.infirmaryLastUsed < cooldownDuration) {
        const remainingTime = Math.ceil(cooldownDuration - (currentTime - player.infirmaryLastUsed));
        showMessageBox(`Infirmary on cooldown. Try again in ${remainingTime} seconds.`);
        return;
      }
      let canAfford = true;
      let costString = '';
      for (const mat in INFIRMARY_HEAL_COST) {
        if (player.inventory[mat] < INFIRMARY_HEAL_COST[mat]) {
          canAfford = false;
        }
        costString += `${INFIRMARY_HEAL_COST[mat]} ${materials[mat].name} `;
      }
      if (player.health < player.maxHealth) {
        if (canAfford) {
          for (const mat in INFIRMARY_HEAL_COST) {
            player.inventory[mat] -= INFIRMARY_HEAL_COST[mat];
          }
          player.health = player.maxHealth;
          player.infirmaryLastUsed = currentTime;
          showMessageBox(`Health fully restored for ${costString}! Infirmary on cooldown.`);
          drawHUD();
        } else {
          showMessageBox(`Not enough resources to use Infirmary. Requires: ${costString}`);
        }
      } else {
        showMessageBox("Health is already full.");
      }
    }

    window.returnToHub = () => {
      if (gameLoopId) cancelAnimationFrame(gameLoopId);
      gameState = 'starbase_hub';
      setupStarbaseHub();
      player.isDashing = false;
      showOverlay(null);
      document.getElementById('autoShootToggle').style.display = 'none';
      document.getElementById('abortMissionButton').style.display = 'none';
      lastTime = performance.now();
      gameLoopId = requestAnimationFrame(gameLoop);
    };
    window.startGame = (mapId) => {
      activeMap = maps.find(m => m.id === mapId);
      resetForMission();
      gameState = 'playing';
      showOverlay(null);
    };

    function setupStarbaseHub() {
      // Player starts at the center of the hub
      player.x = starbaseHub.rect.x + starbaseHub.rect.width / 2;
      player.y = starbaseHub.rect.y + starbaseHub.rect.height / 2;
      player.stamina = player.maxStamina;
      applyPermanentUpgrades();
    }

    function showMapSelection() {
      gameState = 'mapSelection';
      let mapCardsHTML = maps.map(map => `
                <div class="map-card p-4 flex flex-col justify-between">
                    <div>
                        <h3 class="card-title text-2xl mb-2">${map.name}</h3>
                        <p class="card-desc">${map.description}</p>
                    </div>
                    <div class="mt-4 text-xs">
                        <p>Expected Resources:</p>
                        ${map.resources.map(r => `<span style="color:${materials[r].color}">${materials[r].name}</span>`).join(', ')}
                    </div>
                    <button onclick="window.startGame('${map.id}')" class="game-button mt-4 text-sm px-4 py-2">Deploy</button>
                </div>`).join('');

      let content = `
                <h1 class="text-4xl mb-4 text-orange-300">Mission Deployment Terminal</h1>
                <p class="text-lg mb-8 text-gray-400">Select your destination.</p>
                <div class="flex-grow flex flex-col items-center overflow-y-auto w-full"> <!-- Added flex-grow and overflow -->
                    <div class="map-cards-grid">
                        ${mapCardsHTML}
                    </div>
                </div>
                <button onclick="window.returnToHub()" class="game-button mt-8 text-sm px-6 py-3">Abort Deployment</button>`;
      showOverlay('mapSelection', content);
    }

    function setupPlayer() {
      Object.assign(player, {
        width: 16,
        height: 24,
        speed: 200,
        staminaRegen: 25,
        dashCost: 40,
        isDashing: false,
        dashCooldown: 0,
        dashDuration: 0.15,
        dashSpeed: 600,
        level: 1,
        xp: 0,
        xpToNextLevel: 100,
        xpGainMultiplier: 1.0,
        fireCooldown: 0,
        animTimer: 0,
        animFrame: 0,
        isMoving: false,
        inventory: {
          moondust: 1000,
          alien_chitin: 1000,
          plant_fiber: 1000,
          goop: 1000,
          ice_crystal: 1000,
          seaweed: 1000,
          frost_shard: 1000,
          magma_rock: 1000,
          fin: 1000
        }, // Added all new materials to inventory
        upgrades: {
          suit_hp: 0, suit_regen: 0, suit_stamina: 0,
          gun_dmg: 0, gun_rate: 0, gun_proj_speed: 0,
          drone_unlock: 0, rover_unlock: 0, orbital_unlock: 0
        },
        currentWeaponId: 'blaster',
        ownedWeapons: {'blaster': true},
        autoShoot: false,
        infirmaryLastUsed: -Infinity,
        daysPassed: 1,
        drones: 0,
        orbitalCooldownMultiplier: 1.0
      });
      // Initialize rover properties
      Object.assign(rover, {
        active: false,
        x: 0, y: 0,
        fireCooldown: 0,
        fireRate: 0.8, // Rover base fire rate
        projectilesPerShot: 1, // Rover's own projectile count
        projectileSpeed: 250,
        damage: 7,
      });

      player.baseMaxHealth = 100;
      player.baseMaxStamina = 100;
      applyPermanentUpgrades();
      player.health = player.maxHealth;
      player.stamina = player.maxStamina;
    }

    function applyPermanentUpgrades() {
      player.maxHealth = player.baseMaxHealth + player.upgrades.suit_hp * 10;
      player.healthRegen = player.upgrades.suit_regen * 0.1;
      player.maxStamina = player.baseMaxStamina + player.upgrades.suit_stamina * 10;

      const equippedWeapon = weapons[player.currentWeaponId];
      player.attackPower = equippedWeapon.baseDamage + player.upgrades.gun_dmg
      player.fireRate = equippedWeapon.baseFireRate * (1 + player.upgrades.gun_rate * 0.05);
      player.projectileSpeed = equippedWeapon.baseProjectileSpeed + player.upgrades.gun_proj_speed * 10;

      // Player's projectiles per shot should only be based on their weapon, not rover's
      player.projectilesPerShot = (equippedWeapon.projectilesPerShot || 1);

      // BFG specific explosion radius (defaults to 0 if not BFG)
      player.explosionRadius = equippedWeapon.explosionRadius || 0;

      if (player.projectilesPerShot > 1 && !equippedWeapon.spreadAngle) {
        player.spreadAngle = 0.2;
      } else {
        player.spreadAngle = equippedWeapon.spreadAngle || 0;
      }
    }

    function resetForMission() {
      player.drones = player.upgrades.drone_unlock; // Drones unlock state determines if player has drones
      rover.active = player.upgrades.rover_unlock === 1; // Rover unlock state
      if (rover.active) {
        rover.x = player.x;
        rover.y = player.y;
        rover.projectilesPerShot = 1; // Reset rover projectiles per shot at mission start, increased by power-ups
        rover.fireCooldown = 0; // Reset rover fire cooldown
      }
      orbitalStrike.enabled = player.upgrades.orbital_unlock === 1;
      orbitalStrike.timer = orbitalStrike.cooldown;
      player.orbitalCooldownMultiplier = 1.0;
      syncDrones();
      applyPermanentUpgrades();

      if (gameState === 'gameOver') {
        player.health = player.maxHealth;
        player.stamina = player.maxStamina;
      }

      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
      timer = gameDuration;
      [enemies, playerProjectiles, enemyProjectiles, shards, materialDrops, terrain, particles, missiles].forEach(arr => arr.length = 0);
      const terrainCount = 25;

      // Generate terrain based on active map
      if (activeMap.id === 'planet_v2') {
        for (let i = 0; i < terrainCount; i++) terrain.push({
          type: 'shrub',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height
        });
      } else if (activeMap.id === 'cratered_moon') {
        for (let i = 0; i < terrainCount; i++) {
          terrain.push({
            type: 'rock',
            subType: Math.ceil(Math.random() * 2),
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: 20
          });
        }
      } else if (activeMap.id === 'verdant_prime') {
        for (let i = 0; i < terrainCount; i++) {
          terrain.push({
            type: 'plant',
            subType: Math.ceil(Math.random() * 3),
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: 15
          });
        }
      } else if (activeMap.id === 'icy_planet') { // New terrain for icy_planet
        for (let i = 0; i < 10; i++) terrain.push({
          type: 'ice_cave',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 30
        });
        for (let i = 0; i < 15; i++) terrain.push({
          type: 'ice_patch',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 25
        });
      } else if (activeMap.id === 'red_planet') { // New terrain for red_planet
        for (let i = 0; i < 10; i++) terrain.push({
          type: 'large_rock',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 35
        });
        for (let i = 0; i < 15; i++) terrain.push({
          type: 'dunes',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 30
        });
      } else if (activeMap.id === 'coral_beach') { // New terrain for coral_beach
        for (let i = 0; i < 10; i++) terrain.push({
          type: 'palm_tree',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 20
        });
        for (let i = 0; i < 15; i++) terrain.push({
          type: 'coral_formation',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 18
        });
      }

      // Generate resource nodes based on active map
      if (activeMap.resources.includes('moondust')) {
        for (let i = 0; i < 5; i++) terrain.push({
          type: 'resource_node',
          material: 'moondust',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 15,
          health: 30,
          maxHealth: 30
        });
      }
      if (activeMap.resources.includes('plant_fiber')) {
        for (let i = 0; i < 5; i++) terrain.push({
          type: 'resource_node',
          material: 'plant_fiber',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 15,
          health: 30,
          maxHealth: 30
        });
      }
      if (activeMap.resources.includes('ice_crystal')) {
        for (let i = 0; i < 5; i++) terrain.push({
          type: 'resource_node',
          material: 'ice_crystal',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 15,
          health: 30,
          maxHealth: 30
        });
      }
      if (activeMap.resources.includes('seaweed')) {
        for (let i = 0; i < 5; i++) terrain.push({
          type: 'resource_node',
          material: 'seaweed',
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: 15,
          health: 30,
          maxHealth: 30
        });
      }

      waveConfig = {spawnInterval: 3, lastSpawnTime: 0};
    }

    function updatePlayer(deltaTime) {
      let nextX = player.x;
      let nextY = player.y;
      if (gameState === 'playing') {
        player.dashCooldown -= deltaTime;
        if (keys[' '] && !player.isDashing && player.stamina >= player.dashCost && player.dashCooldown <= 0) {
          startDash();
        }
      }
      player.fireCooldown -= deltaTime;
      player.stamina = Math.min(player.maxStamina, player.stamina + player.staminaRegen * deltaTime);
      if (gameState === 'playing') player.health = Math.min(player.maxHealth, player.health + player.healthRegen * deltaTime);
      let moveDirection = {x: 0, y: 0};
      if (keys.a) moveDirection.x -= 1;
      if (keys.d) moveDirection.x += 1;
      if (keys.w) moveDirection.y -= 1;
      if (keys.s) moveDirection.y += 1;
      player.isMoving = (moveDirection.x !== 0 || moveDirection.y !== 0);
      if (player.isMoving) {
        player.animTimer += deltaTime;
        if (player.animTimer > 0.2) {
          player.animTimer = 0;
          player.animFrame = (player.animFrame + 1) % 2;
        }
        const currentSpeed = player.isDashing ? player.dashSpeed : player.speed;
        const magnitude = Math.sqrt(moveDirection.x ** 2 + moveDirection.y ** 2);
        if (magnitude > 0) {
          nextX += (moveDirection.x / magnitude) * currentSpeed * deltaTime;
          nextY += (moveDirection.y / magnitude) * currentSpeed * deltaTime;
        }
      } else {
        player.animFrame = 0;
      }

      // Apply bounds checking based on game state
      let bounds;
      if (gameState === 'starbase_hub' || gameState === 'station_menu') {
        bounds = starbaseHub.rect;
      } else { // In mission
        bounds = {x: 0, y: 0, width: canvas.width, height: canvas.height};
      }

      // Collision with static terrain objects (rocks, plants, etc.)
      let collided = false;
      terrain.forEach(t => {
        // Collision for all obstacle types
        if (['rock', 'plant', 'large_rock', 'ice_cave', 'palm_tree', 'ice_patch', 'dunes', 'coral_formation'].includes(t.type)) {
          if (Math.hypot(nextX - t.x, nextY - t.y) < (t.radius || 20) + player.width / 2) { // Use default radius if not specified
            collided = true;
          }
        }
      });

      // Specific collision for water on Azure Coast
      if (activeMap && activeMap.id === 'coral_beach') {
        const waterTopY = canvas.height - (canvas.height / 5); // Top edge of the water
        if (nextY + player.height / 2 > waterTopY) { // If player is trying to enter water
          nextY = waterTopY - player.height / 2; // Clamp player to the sand
        }
      }

      // Apply movement if no collision with obstacles
      if (!collided) {
        player.x = nextX;
        player.y = nextY;
      }

      // Always clamp player to overall canvas/hub boundaries
      player.x = Math.max(bounds.x + player.width / 2, Math.min(bounds.x + bounds.width - player.width / 2, player.x));
      player.y = Math.max(bounds.y + player.height / 2, Math.min(bounds.y + bounds.height - player.height / 2, player.y));
    }

    function updateHub(deltaTime) {
      updatePlayer(deltaTime);
      updateStars(deltaTime);
      interactionTarget = null;
      for (const item of starbaseHub.interactables) {
        if (Math.hypot(player.x - item.x, player.y - item.y) < starbaseHub.interactionRadius) {
          interactionTarget = item;
          break;
        }
      }
    }

    function createShard(x, y, value) {
      shards.push({x, y, value, radius: 4});
    }

    function createMaterialDrop(x, y, type) {
      materialDrops.push({x, y, type});
    }

    function updateEnemies(deltaTime) {
      for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
        const p = enemyProjectiles[i];
        p.x += p.vx * p.speed * deltaTime;
        p.y += p.vy * p.speed * deltaTime;
        p.lifespan -= deltaTime;
        if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height || p.lifespan <= 0) {
          enemyProjectiles.splice(i, 1);
          continue;
        }
        if (Math.hypot(p.x - player.x, p.y - player.y) < player.width / 2 + p.radius) {
          player.health -= p.damage;
          enemyProjectiles.splice(i, 1);
          if (player.health <= 0) {
            gameState = 'gameOver';
          }
        }
      }
      enemies.forEach(enemy => {
        const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        // General movement and attack logic based on enemy type
        if (enemy.type === 'charger') {
          if (enemy.state === 'moving') {
            if (distToPlayer < enemy.attackRadius * 0.8) {
              enemy.state = 'charging';
              enemy.chargeTimer = 0;
            } else {
              enemy.x += Math.cos(angle) * enemy.speed * deltaTime;
              enemy.y += Math.sin(angle) * enemy.speed * deltaTime;
            }
          } else if (enemy.state === 'charging') {
            enemy.chargeTimer += deltaTime;
            if (enemy.chargeTimer >= enemy.chargeTime) {
              enemy.state = 'attacking';
              if (distToPlayer < enemy.attackRadius) {
                player.health -= enemy.attackDamage;
                if (player.health <= 0) {
                  gameState = 'gameOver';
                }
              }
              setTimeout(() => {
                if (enemy) enemy.state = 'moving';
              }, 500);
            }
          }
        } else if (enemy.type === 'spitter' || enemy.type === 'heat_worm') { // Ranged enemies
          enemy.fireCooldown -= deltaTime;
          if (distToPlayer > enemy.preferredDist) {
            enemy.x += Math.cos(angle) * enemy.speed * deltaTime;
            enemy.y -= Math.sin(angle) * enemy.speed * deltaTime;
          } else {
            enemy.x -= Math.cos(angle) * enemy.speed * 0.5 * deltaTime;
            enemy.y -= Math.sin(angle) * enemy.speed * 0.5 * deltaTime;
          }
          if (enemy.fireCooldown <= 0) {
            fireEnemyProjectile(enemy);
          }
        } else { // All melee types (worm, squid, ice_crawler, frost_beetle, snow_serpent, sand_beast, scorpion_drone, crab_mutant, jellyfish, piranha_swarm)
          enemy.x += Math.cos(angle) * enemy.speed * deltaTime;
          enemy.y += Math.sin(angle) * enemy.speed * deltaTime;
          enemy.attackCooldown -= deltaTime;
          if (distToPlayer < enemy.size + player.width / 2 && enemy.attackCooldown <= 0) {
            player.health -= enemy.attackDamage;
            enemy.attackCooldown = 1 / enemy.attackRate;
            if (player.health <= 0) {
              gameState = 'gameOver';
            }
          }
        }
      });
    }

    function createEnemy() {
      const allowedAlienTypes = mapToAlienTypes[activeMap.id];
      if (!allowedAlienTypes || allowedAlienTypes.length === 0) {
        console.warn(`No alien types defined for map: ${activeMap.id}`);
        return;
      }
      const type = allowedAlienTypes[Math.floor(Math.random() * allowedAlienTypes.length)];
      const data = alienData[type];

      let x, y;
      let size = 15; // Default size, can be overridden by specific alien data
      let speed = data.speed;
      let enemySpecificProps = {};

      // Assign specific properties from alienData
      Object.assign(enemySpecificProps, {
        attackDamage: data.attackDamage,
        attackCooldown: data.attackCooldown,
        attackRate: data.attackRate,
        fireCooldown: data.fireCooldown,
        fireRate: data.fireRate,
        preferredDist: data.preferredDist,
        state: data.state,
        chargeTime: data.chargeTime,
        chargeTimer: data.chargeTimer,
        attackRadius: data.attackRadius
      });

      // Set size based on type if not already defined
      if (type === 'charger') size = 16;
      else if (type === 'spitter') size = 12;
      else if (type === 'worm') size = 18;
      else if (type === 'squid') size = 15;
      else if (type === 'ice_crawler') size = 15;
      else if (type === 'frost_beetle') size = 20; // Size for Frost Beetle
      else if (type === 'snow_serpent') size = 18; // Size for Snow Serpent
      else if (type === 'sand_beast') size = 25;
      else if (type === 'scorpion_drone') size = 15; // Size for Scorpion Drone
      else if (type === 'heat_worm') size = 25; // Size for Heat Worm
      else if (type === 'crab_mutant') size = 20;
      else if (type === 'jellyfish') size = 18; // Size for Jellyfish
      else if (type === 'piranha_swarm') size = 20; // Size for Piranha Swarm (overall size of swarm)


      const edge = Math.floor(Math.random() * 4);
      if (edge === 0) {
        x = Math.random() * canvas.width;
        y = -size;
      } else if (edge === 1) {
        x = canvas.width + size;
        y = Math.random() * canvas.height;
      } else if (edge === 2) {
        x = Math.random() * canvas.width;
        y = canvas.height + size;
      } else {
        x = -size;
        y = Math.random() * canvas.height;
      }

      let newEnemy = {
        x,
        y,
        size,
        health: data.health,
        maxHealth: data.health,
        xpValue: data.xpValue,
        type,
        speed,
        drops: data.drops, ...enemySpecificProps
      };
      enemies.push(newEnemy);
    }

    function fireEnemyProjectile(enemy) {
      enemy.fireCooldown = 1 / enemy.fireRate;
      const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      for (let i = -1; i <= 1; i++) {
        const angle = baseAngle + i * 0.2;
        enemyProjectiles.push({
          x: enemy.x,
          y: enemy.y,
          radius: 5,
          color: '#A3E635',
          speed: 150,
          vx: Math.cos(angle),
          vy: Math.sin(angle),
          damage: 8,
          lifespan: 1.5
        });
      }
    }

    function startDash() {
      player.isDashing = true;
      player.stamina -= player.dashCost;
      player.dashCooldown = 0.5;
      setTimeout(() => player.isDashing = false, player.dashDuration * 1000);
    }

    function fireProjectile() {
      player.fireCooldown = 1 / player.fireRate;
      const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      const equippedWeapon = weapons[player.currentWeaponId];

      for (let i = 0; i < player.projectilesPerShot; i++) {
        const currentAngle = angle + (i - (player.projectilesPerShot - 1) / 2) * player.spreadAngle;
        const isBFG = (player.currentWeaponId === 'bfg');
        playerProjectiles.push({
          x: player.x, y: player.y,
          radius: (isBFG ? 8 : 4),
          color: (player.currentWeaponId === 'phaser' ? '#A78BFA' : '#FBBF24'),
          speed: player.projectileSpeed,
          vx: Math.cos(currentAngle), vy: Math.sin(currentAngle),
          damage: player.attackPower,
          isBFG: isBFG, // Mark as BFG projectile
          explosionRadius: equippedWeapon.explosionRadius || 0, // BFG explosion radius from weapon data
          source: 'player'
        });
      }
    }

    function findNearestEnemy(x, y, range) {
      let nearest = null;
      let minDistance = range;
      enemies.forEach(enemy => {
        const dist = Math.hypot(x - enemy.x, y - enemy.y);
        if (dist < minDistance) {
          minDistance = dist;
          nearest = enemy;
        }
      });
      return nearest;
    }

    function fireDroneProjectile(drone, target) {
      const angle = Math.atan2(target.y - drone.y, target.x - drone.x);
      playerProjectiles.push({
        x: drone.x, y: drone.y, radius: 3, color: '#38bdf8', // Light blue for drone shots
        speed: 400, vx: Math.cos(angle), vy: Math.sin(angle), damage: 5,
        source: 'drone'
      });
    }

    // New function for rover firing
    function fireRoverProjectile(rover, target) {
      const angle = Math.atan2(target.y - rover.y, target.x - rover.x);
      for (let i = 0; i < rover.projectilesPerShot; i++) {
        const spreadAngle = (rover.projectilesPerShot > 1) ? 0.1 : 0; // Small spread for multiple rover shots
        const currentAngle = angle + (i - (rover.projectilesPerShot - 1) / 2) * spreadAngle;
        playerProjectiles.push({
          x: rover.x, y: rover.y, radius: 4, color: '#facc15', // Yellow for rover shots
          speed: rover.projectileSpeed, vx: Math.cos(currentAngle), vy: Math.sin(currentAngle), damage: rover.damage,
          source: 'rover'
        });
      }
    }

    function syncDrones() {
      drones.length = 0;
      if (player.drones > 0) {
        for (let i = 0; i < player.drones; i++) {
          drones.push({
            angle: (Math.PI * 2 / player.drones) * i,
            orbitRadius: 60, fireCooldown: 0, fireRate: 1.5,
            x: 0, y: 0
          });
        }
      }
    }

    function updateDrones(deltaTime) {
      if (!drones.length) return;
      drones.forEach((drone) => {
        drone.angle += 1.5 * deltaTime;
        drone.x = player.x + Math.cos(drone.angle) * drone.orbitRadius;
        drone.y = player.y + Math.sin(drone.angle) * drone.orbitRadius;
        drone.fireCooldown -= deltaTime;
        if (drone.fireCooldown <= 0) {
          const nearestEnemy = findNearestEnemy(drone.x, drone.y, 300);
          if (nearestEnemy) {
            fireDroneProjectile(drone, nearestEnemy);
            drone.fireCooldown = 1 / drone.fireRate;
          }
        }
      });
    }

    function updateRover(deltaTime) {
      if (!rover.active) return;
      const targetX = player.x - (mouse.facingRight ? 40 : -40);
      const targetY = player.y + 20;
      rover.x += (targetX - rover.x) * 0.1;
      rover.y += (targetY - rover.y) * 0.1;

      // Rover firing logic
      rover.fireCooldown -= deltaTime;
      if (rover.fireCooldown <= 0) {
        const nearestEnemy = findNearestEnemy(rover.x, rover.y, 400); // Rover has a range
        if (nearestEnemy) {
          fireRoverProjectile(rover, nearestEnemy);
          rover.fireCooldown = 1 / rover.fireRate;
        }
      }
    }

    function createExplosion(x, y, radius, damage, count = 20) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 150 + 50;
        particles.push({
          x: x, y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size: Math.random() * 3 + 2,
          color: `rgba(251, 146, 60, ${Math.random() * 0.5 + 0.5})`,
          lifetime: Math.random() * 0.8 + 0.4
        });
      }
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (Math.hypot(x - e.x, y - e.y) < radius) {
          e.health -= damage;
          if (e.health <= 0) {
            createShard(e.x, e.y, e.xpValue);
            e.drops.forEach(drop => {
              if (Math.random() < drop.chance) {
                createMaterialDrop(e.x, e.y, drop.material);
              }
            });
            enemies.splice(i, 1);
          }
        }
      }
    }

    function updateParticles(deltaTime) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * deltaTime;
        p.y += p.vy * deltaTime;
        p.vx *= 0.98;
        p.vy *= 0.98; // friction
        p.lifetime -= deltaTime;
        if (p.lifetime <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function updateOrbitalStrike(deltaTime) {
      if (!orbitalStrike.enabled || enemies.length === 0) {
        orbitalStrike.target = null;
        return;
      }
      if (missiles.length > 0) return; // Wait for current missile to hit

      orbitalStrike.timer -= deltaTime;
      if (orbitalStrike.timer <= 0) {
        orbitalStrike.timer = orbitalStrike.cooldown * player.orbitalCooldownMultiplier;
        const targetEnemy = enemies[Math.floor(Math.random() * enemies.length)];
        missiles.push({
          startX: targetEnemy.x + (Math.random() - 0.5) * 400,
          startY: -20,
          endX: targetEnemy.x,
          endY: targetEnemy.y,
          progress: 0
        });
      }
    }

    // function updateMissiles(deltaTime) {
    //     for (let i = missiles.length - 1; i >= 0; i--) {
    //         const m = missiles[i];
    //         m.progress += 4 * deltaTime;
    //         m.x = m.startX + (m.endX - m.startX) * m.progress;
    //         m.y = m.startY + (m.endY - m.startY) * m.progress;
    //         m.angle = Math.atan2(m.endY - m.startY, m.endX - m.startX);
    //
    //         if (m.progress >= 1) {
    //             createExplosion(m.x, m.y, orbitalStrike.explosionRadius, orbitalStrike.damage, 40);
    //             missiles.splice(i, 1);
    //         }
    //     }
    // }

    function updatePlaying(deltaTime) {
      if (gameState !== 'playing') return;
      timer -= deltaTime;
      if (timer <= 0) {
        gameState = 'victory';
        return;
      }
      updatePlayer(deltaTime);
      updateEnemies(deltaTime);
      updateDrones(deltaTime);
      updateRover(deltaTime);
      updateOrbitalStrike(deltaTime);
      updateParticles(deltaTime);

      waveConfig.lastSpawnTime += deltaTime;
      // Adjust spawn interval based on current map and time remaining
      // New maps might have different difficulty curves
      let currentSpawnInterval = 3; // Default
      if (activeMap.id === 'icy_planet' || activeMap.id === 'red_planet' || activeMap.id === 'coral_beach') {
        if (timer < 90) currentSpawnInterval = 2.0;
        else if (timer < 60) currentSpawnInterval = 1.0;
        else if (timer < 30) currentSpawnInterval = 0.5;
      } else { // Original planets
        if (timer < 90) currentSpawnInterval = 2.5;
        else if (timer < 60) currentSpawnInterval = 1.5;
        else if (timer < 30) currentSpawnInterval = 0.8;
      }
      waveConfig.spawnInterval = currentSpawnInterval;

      if (waveConfig.lastSpawnTime > waveConfig.spawnInterval) {
        waveConfig.lastSpawnTime = 0;
        const spawnCount = 1 + Math.floor((gameDuration - timer) / 40);
        for (let i = 0; i < spawnCount; i++) createEnemy();
      }

      for (let i = playerProjectiles.length - 1; i >= 0; i--) {
        const p = playerProjectiles[i];
        p.x += p.vx * p.speed * deltaTime;
        p.y += p.vy * p.speed * deltaTime;
        if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
          playerProjectiles.splice(i, 1);
          continue;
        }

        let projectileRemoved = false;

        // Check collision with terrain (resource nodes)
        for (let t_idx = terrain.length - 1; t_idx >= 0; t_idx--) {
          const t = terrain[t_idx];
          if (t.type !== 'resource_node') continue;
          if (Math.hypot(p.x - t.x, p.y - t.y) < t.radius + p.radius) {
            t.health -= p.damage;
            if (p.isBFG) { // BFG explodes on resource node hit
              createExplosion(p.x, p.y, p.explosionRadius, p.damage);
            }
            if (t.health <= 0) {
              createMaterialDrop(t.x, t.y, t.material);
              terrain.splice(t_idx, 1);
            }
            playerProjectiles.splice(i, 1);
            projectileRemoved = true;
            break;
          }
        }
        if (projectileRemoved) continue;

        // Check collision with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (Math.hypot(p.x - e.x, p.y - e.y) < e.size + p.radius) {
            e.health -= p.damage;
            if (p.isBFG) { // BFG explodes on enemy hit
              createExplosion(e.x, e.y, p.explosionRadius, p.damage);
            }

            // For BFG, it explodes and is removed.
            // For other weapons, remove on first hit.
            playerProjectiles.splice(i, 1);
            projectileRemoved = true;

            if (e.health <= 0) {
              createExplosion(e.x, e.y, e.size * 1.5, 0, 10); // death explosion
              e.drops.forEach(drop => {
                if (Math.random() < drop.chance) {
                  createMaterialDrop(e.x, e.y, drop.material);
                }
              });
              createShard(e.x, e.y, e.xpValue);
              enemies.splice(j, 1);
            }
            if (projectileRemoved) break;
          }
        }
      }

      for (let i = shards.length - 1; i >= 0; i--) {
        if (Math.hypot(player.x - shards[i].x, player.y - shards[i].y) < player.width * 4) {
          gainXp(shards[i].value);
          shards.splice(i, 1);
        }
      }
      for (let i = materialDrops.length - 1; i >= 0; i--) {
        if (Math.hypot(player.x - materialDrops[i].x, player.y - materialDrops[i].y) < player.width * 4) {
          player.inventory[materialDrops[i].type]++;
          materialDrops.splice(i, 1);
        }
      }
    }

    function gainXp(amount) {
      player.xp += amount * player.xpGainMultiplier;
      if (player.xp >= player.xpToNextLevel) levelUp();
    }

    function levelUp() {
      player.level++;
      player.xp -= player.xpToNextLevel;
      player.xpToNextLevel = Math.floor(100 * Math.pow(1.5, player.level - 1));
      presentUpgradeChoices();
    }

    function presentUpgradeChoices() {
      gameState = 'paused';
      let availableUpgrades = [...powerUps];
      // Filter out drone_add if drone_unlock is not yet purchased
      if (player.upgrades.drone_unlock === 0) availableUpgrades = availableUpgrades.filter(u => u.id !== 'drone_add');
      // Filter out rover_upgrade if rover_unlock is not yet purchased
      if (player.upgrades.rover_unlock === 0) availableUpgrades = availableUpgrades.filter(u => u.id !== 'rover_upgrade');
      if (player.upgrades.orbital_unlock === 0) availableUpgrades = availableUpgrades.filter(u => u.id !== 'orbital_cooldown');

      const choices = availableUpgrades.sort(() => 0.5 - Math.random()).slice(0, 3);
      let cardsHTML = `<div class="w-full flex justify-center">${choices.map(upgrade => `
                <div class="upgrade-card" onclick="window.selectUpgrade('${upgrade.id}')">
                    <h2 class="card-title">${upgrade.title}</h2>
                    <p class="card-desc">${upgrade.desc}</p>
                </div>`).join('')}</div>`;
      showOverlay('levelUpSelection', `<h1 class="text-4xl mb-8 text-green-300">System Upgrade Available</h1>${cardsHTML}`);
    }

    window.selectUpgrade = (upgradeId) => {
      const upgrade = powerUps.find(u => u.id === upgradeId);
      upgrade.apply(player);
      showOverlay(null);
      gameState = 'playing';
    }

    function openStationMenu(stationId) {
      gameState = 'station_menu';
      activeStation = stationId;
      selectedUpgradeId = null;
      selectedWeaponId = null;

      const stationMenuTitleEl = document.getElementById('stationMenuTitle');
      const upgradeDetailsBoxEl = document.getElementById('upgradeDetailsBox');

      stationMenuTitleEl.textContent = `${stationId.charAt(0).toUpperCase() + stationId.slice(1)}`;
      upgradeDetailsBoxEl.style.display = 'none';

      if (stationId === 'armory') {
        document.querySelector('.station-tabs').style.display = 'flex';
        // Trigger click on weapons tab to ensure it's active and populated
        document.querySelector('.station-tab[data-tab="weapons"]').click();
      } else {
        document.querySelector('.station-tabs').style.display = 'none';
        document.getElementById('upgradesTabContent').classList.add('active');
        document.getElementById('weaponsTabContent').classList.remove('active');
        populateUpgradesTab(permanentUpgrades[stationId]);
      }

      showOverlay('stationMenu');
    }

    document.querySelectorAll('.station-tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        document.querySelectorAll('.station-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
        e.target.classList.add('active');
        const targetTab = e.target.dataset.tab;
        document.getElementById(targetTab + 'TabContent').classList.add('active');

        selectedWeaponId = null;
        selectedUpgradeId = null;
        document.getElementById('upgradeDetailsBox').style.display = 'none';

        if (targetTab === 'weapons') {
          populateWeaponsTab();
        } else if (targetTab === 'upgrades') {
          populateUpgradesTab(permanentUpgrades[activeStation]);
        }
      });
    });

    function populateWeaponsTab() {
      const weaponIconsContainerEl = document.getElementById('weaponIconsContainer');
      weaponIconsContainerEl.innerHTML = '';
      Object.values(weapons).forEach(weapon => {
        const isEquipped = player.currentWeaponId === weapon.id;
        // const isOwned = player.ownedWeapons[weapon.id];
        const iconButton = document.createElement('div');
        iconButton.className = `upgrade-icon-button ${isEquipped ? 'equipped' : ''}`;
        iconButton.innerHTML = `${weapon.icon}<br><span class="icon-text">${weapon.name}</span>`;
        iconButton.onclick = () => window.displayWeaponDetails(weapon.id);
        weaponIconsContainerEl.appendChild(iconButton);
      });
    }

    window.displayWeaponDetails = (weaponId) => {
      selectedWeaponId = weaponId;
      selectedUpgradeId = null;
      const weapon = weapons[weaponId];
      if (!weapon) return;

      const isOwned = player.ownedWeapons[weapon.id];
      const isEquipped = player.currentWeaponId === weapon.id;
      const cost = weapon.cost;
      let canAfford = true;
      let costHtml = '';

      if (!isOwned) {
        for (const mat in cost) {
          if (player.inventory[mat] < cost[mat]) canAfford = false;
          costHtml += `<span style="color:${materials[mat].color};">${cost[mat]} ${materials[mat].name}</span> `;
        }
      }

      const detailTitleEl = document.getElementById('detailTitle');
      const detailDescEl = document.getElementById('detailDesc');
      const detailLevelEl = document.getElementById('detailLevel');
      const detailCostEl = document.getElementById('detailCost');
      const detailBuyButtonEl = document.getElementById('detailBuyButton');
      const upgradeDetailsBoxEl = document.getElementById('upgradeDetailsBox');

      detailTitleEl.textContent = weapon.name;
      detailDescEl.textContent = weapon.description;

      if (isEquipped) {
        detailLevelEl.textContent = 'Status: EQUIPPED';
        detailCostEl.innerHTML = '';
        detailBuyButtonEl.textContent = 'EQUIPPED';
        detailBuyButtonEl.disabled = true;
      } else if (isOwned) {
        detailLevelEl.textContent = 'Status: OWNED';
        detailCostEl.innerHTML = '';
        detailBuyButtonEl.textContent = 'Equip';
        detailBuyButtonEl.disabled = false;
        detailBuyButtonEl.onclick = () => window.equipWeapon(weapon.id);
      } else {
        detailLevelEl.textContent = 'Status: NOT OWNED';
        detailCostEl.innerHTML = `Cost: ${costHtml}`;
        detailBuyButtonEl.textContent = 'Buy';
        detailBuyButtonEl.disabled = !canAfford;
        detailBuyButtonEl.onclick = () => window.buyWeapon(weapon.id);
      }

      detailBuyButtonEl.className = `game-button mt-4 w-full ${detailBuyButtonEl.disabled ? 'disabled' : ''}`;
      upgradeDetailsBoxEl.style.display = 'flex';

      document.querySelectorAll('.upgrade-icon-button').forEach(btn => btn.classList.remove('selected'));
      document.querySelectorAll('#weaponIconsContainer .upgrade-icon-button').forEach(btn => {
        // Check if the button's inner HTML contains the weapon's icon and name for accurate selection
        if (btn.innerHTML.includes(weapon.icon) && btn.innerHTML.includes(weapon.name)) {
          btn.classList.add('selected');
        }
      });
    };

    window.equipWeapon = (weaponId) => {
      if (player.ownedWeapons[weaponId] && player.currentWeaponId !== weaponId) {
        player.currentWeaponId = weaponId;
        applyPermanentUpgrades();
        populateWeaponsTab();
        displayWeaponDetails(weaponId);
        showMessageBox(`${weapons[weaponId].name} equipped!`);
      }
    };

    window.buyWeapon = (weaponId) => {
      const weapon = weapons[weaponId];
      if (player.ownedWeapons[weaponId]) {
        return;
      }
      const cost = weapon.cost;
      let canAfford = true;
      for (const mat in cost) {
        if (player.inventory[mat] < cost[mat]) {
          canAfford = false;
          break;
        }
      }
      if (canAfford) {
        for (const mat in cost) {
          player.inventory[mat] -= cost[mat];
        }
        player.ownedWeapons[weaponId] = true;
        updateMaterialHUD();
        populateWeaponsTab();
        displayWeaponDetails(weaponId);
        showMessageBox(`Successfully purchased ${weapon.name}!`);
      } else {
        showMessageBox("Cannot afford this weapon!");
      }
    };

    function populateUpgradesTab(upgradesForStation) {
      const upgradeIconsContainerEl = document.getElementById('upgradeIconsContainer');
      upgradeIconsContainerEl.innerHTML = '';
      upgradesForStation.forEach(upgrade => {
        const currentLevel = player.upgrades[upgrade.id];
        const isMaxLevel = currentLevel >= upgrade.maxLevel;
        const cost = upgrade.cost(currentLevel);
        let canAfford = true;
        for (const mat in cost) {
          if (player.inventory[mat] < cost[mat]) canAfford = false;
        }
        const iconButton = document.createElement('div');
        iconButton.className = `upgrade-icon-button ${isMaxLevel ? 'is-max' : ''} ${canAfford && !isMaxLevel ? 'can-afford' : ''}`;
        iconButton.innerHTML = `${upgrade.icon}<br><span class="icon-text">${upgrade.name}<br>Lv ${currentLevel}</span>`; // Show current level
        iconButton.onclick = () => window.displayUpgradeDetails(upgrade.id);
        upgradeIconsContainerEl.appendChild(iconButton);
      });
    }

    window.displayUpgradeDetails = (upgradeId) => {
      selectedUpgradeId = upgradeId;
      selectedWeaponId = null;
      const upgrade = permanentUpgrades[activeStation].find(u => u.id === upgradeId);
      if (!upgrade) return;

      const currentLevel = player.upgrades[upgrade.id];
      const isMaxLevel = currentLevel >= upgrade.maxLevel;
      const cost = upgrade.cost(currentLevel);
      let canAfford = true;
      let costHtml = '';

      for (const mat in cost) {
        if (player.inventory[mat] < cost[mat]) canAfford = false;
        costHtml += `<span style="color:${materials[mat].color};">${cost[mat]} ${materials[mat].name}</span> `;
      }
      const detailTitleEl = document.getElementById('detailTitle');
      const detailDescEl = document.getElementById('detailDesc');
      const detailLevelEl = document.getElementById('detailLevel');
      const detailCostEl = document.getElementById('detailCost');
      const detailBuyButtonEl = document.getElementById('detailBuyButton');
      const upgradeDetailsBoxEl = document.getElementById('upgradeDetailsBox');

      detailTitleEl.textContent = upgrade.name;
      detailDescEl.textContent = upgrade.desc;
      detailLevelEl.textContent = `Level: ${currentLevel}/${upgrade.maxLevel}`;
      detailCostEl.innerHTML = isMaxLevel ? 'Max Level Reached' : `Cost: ${costHtml}`;
      detailBuyButtonEl.textContent = isMaxLevel ? 'MAX LEVEL' : (upgrade.maxLevel > 1 ? 'UPGRADE' : 'UNLOCK');
      detailBuyButtonEl.disabled = isMaxLevel || !canAfford;
      detailBuyButtonEl.onclick = () => window.buyUpgrade(upgrade.id);
      detailBuyButtonEl.className = `game-button mt-4 w-full ${detailBuyButtonEl.disabled ? 'disabled' : ''}`;
      upgradeDetailsBoxEl.style.display = 'flex';

      document.querySelectorAll('.upgrade-icon-button').forEach(btn => btn.classList.remove('selected'));
      document.querySelectorAll('#upgradeIconsContainer .upgrade-icon-button').forEach(btn => {
        // Check if the button's inner HTML contains the upgrade's icon and name for accurate selection
        if (btn.innerHTML.includes(upgrade.icon) && btn.innerHTML.includes(upgrade.name)) {
          btn.classList.add('selected');
        }
      });
    };

    window.buyUpgrade = (upgradeId) => {
      const upgrade = permanentUpgrades[activeStation].find(u => u.id === upgradeId);
      const currentLevel = player.upgrades[upgradeId];
      if (currentLevel >= upgrade.maxLevel) {
        return;
      }
      const cost = upgrade.cost(currentLevel);
      let canAfford = true;
      for (const mat in cost) {
        if (player.inventory[mat] < cost[mat]) {
          canAfford = false;
          break;
        }
      }
      if (canAfford) {
        for (const mat in cost) {
          player.inventory[mat] -= cost[mat];
        }
        player.upgrades[upgradeId]++;
        applyPermanentUpgrades();
        updateMaterialHUD();
        populateUpgradesTab(permanentUpgrades[activeStation]); // Repopulate to show new levels/status
        displayUpgradeDetails(upgradeId); // Update the detail box
        showMessageBox(`Successfully upgraded ${upgrade.name}!`);
      } else {
        showMessageBox("Cannot afford this upgrade!");
      }
    };

    window.closeStationMenu = () => {
      showOverlay(null);
      gameState = 'starbase_hub';
      activeStation = null;
      selectedUpgradeId = null;
      selectedWeaponId = null;
    };

    function updateMaterialHUD() {
      const hudMaterialsEl = document.getElementById('hud-materials');
      let materialsHtml = '<span class="text-orange-300 text-lg">Materials</span><br>';
      for (const matType in materials) {
        // Only show materials the player has a non-zero quantity of, or newly added ones
        if (player.inventory[matType] > 0 || ['frost_shard', 'magma_rock', 'fin'].includes(matType)) {
          materialsHtml += `<span style="color:${materials[matType].color};">${materials[matType].name}: ${player.inventory[matType]}</span><br>`;
        }
      }
      hudMaterialsEl.innerHTML = materialsHtml;
    }

    function drawHUD() {
      // Top-Left HUD (Inventory) is handled by HTML div
      updateMaterialHUD();

      // Top-Center HUD (Timer)
      ctx.font = '24px "Press Start 2P"';
      ctx.textAlign = 'center';
      ctx.fillStyle = 'white';
      if (gameState === 'playing' || gameState === 'paused') {
        const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
        const seconds = Math.floor(timer % 60).toString().padStart(2, '0');
        ctx.fillText(`${minutes}:${seconds}`, canvas.width / 2, 40);
      }

      // Bottom-Left HUD
      ctx.textAlign = 'left';
      ctx.font = '12px "Press Start 2P"';
      const barWidth = 200;
      let yPos = canvas.height - 35;

      // Stamina Bar
      ctx.fillStyle = '#4B5563';
      ctx.fillRect(15, yPos, barWidth, 10);
      ctx.fillStyle = '#F59E0B';
      ctx.fillRect(15, yPos, barWidth * (player.stamina / player.maxStamina), 10);
      yPos -= 25;

      // Health Bar
      ctx.fillStyle = '#4B5563';
      ctx.fillRect(15, yPos, barWidth, 20);
      ctx.fillStyle = '#22C55E';
      ctx.fillRect(15, yPos, barWidth * (player.health / player.maxHealth), 20);
      ctx.strokeStyle = 'white';
      ctx.strokeRect(15, yPos, barWidth, 20);
      yPos -= 20;

      // LVL Text
      ctx.fillText(`LVL: ${player.level}`, 15, yPos);
      yPos -= 20;

      // Day Text (only in hub)
      if (gameState === 'starbase_hub' || gameState === 'station_menu') {
        ctx.fillText(`Day: ${player.daysPassed}`, 15, yPos);
      }

      // Bottom-Center HUD (Weapon)
      ctx.textAlign = 'center';
      ctx.fillText(`Weapon: ${weapons[player.currentWeaponId].name}`, canvas.width / 2, canvas.height - 20);

      // Bottom-Edge HUD (XP Bar)
      const xpBarWidth = canvas.width;
      ctx.fillStyle = '#4B5563';
      ctx.fillRect(0, canvas.height - 5, xpBarWidth, 5);
      ctx.fillStyle = '#A78BFA';
      ctx.fillRect(0, canvas.height - 5, xpBarWidth * (player.xp / player.xpToNextLevel), 5);
    }

    function drawHub() {
      sprites.drawStarbase(ctx, canvas.width, canvas.height, globalAnimTimer);
      // Draw non-collidable furniture first
      sprites.drawTableAndChairs(ctx, starbaseHub.table.x, starbaseHub.table.y);
      sprites.drawBed(ctx, starbaseHub.bed.x, starbaseHub.bed.y, starbaseHub.bed.width, starbaseHub.bed.height);
      sprites.drawKitchen(ctx, starbaseHub.kitchen.x, starbaseHub.kitchen.y, starbaseHub.kitchen.width, starbaseHub.kitchen.height);

      // Draw interactable stations
      starbaseHub.interactables.forEach(item => {
        if (item.id === 'deploy') sprites.drawTerminal(ctx, item.x, item.y, item.width, item.height, globalAnimTimer);
        else if (item.id === 'workshop') sprites.drawWorkshop(ctx, item.x, item.y, item.width, item.height);
        else if (item.id === 'armory') sprites.drawArmory(ctx, item.x, item.y, item.width, item.height);
        else if (item.id === 'garage') sprites.drawGarage(ctx, item.x, item.y, item.width, item.height);
        else if (item.id === 'database') sprites.drawDatabase(ctx, item.x, item.y, item.width, item.height);
        else if (item.id === 'infirmary') sprites.drawInfirmary(ctx, item.x, item.y, item.width, item.height);
      });
      if (interactionTarget) {
        ctx.font = '14px "Press Start 2P"';
        ctx.fillStyle = '#FB923C';
        ctx.textAlign = 'center';
        const yPos = interactionTarget.y - interactionTarget.height * 0.7;
        let xPos = interactionTarget.x;
        const textWidth = ctx.measureText(`[E] Use ${interactionTarget.name}`).width;
        if (xPos - textWidth / 2 < 10) xPos = textWidth / 2 + 10;
        if (xPos + textWidth / 2 > canvas.width - 10) xPos = canvas.width - textWidth / 2 - 10;
        ctx.fillText(`[E] Use`, xPos, yPos);
        ctx.fillText(`${interactionTarget.name}`, xPos, yPos + 16);
      }
      sprites.drawPlayer(ctx, player.x, player.y, player.animFrame, mouse.facingRight);
      drawHUD();
    }

    function drawPlaying() {
      sprites.drawPlanetFloor(ctx, canvas.width, canvas.height);
      terrain.forEach(t => {
        if (t.type === 'rock') sprites.drawRock(ctx, t.x, t.y, t.subType);
        else if (t.type === 'plant') sprites.drawPlant(ctx, t.x, t.y, t.subType);
        else if (t.type === 'shrub') sprites.drawShrub(ctx, t.x, t.y);
        else if (t.type === 'resource_node') sprites.drawResourceNode(ctx, t);
        else if (t.type === 'ice_cave') sprites.drawIceCave(ctx, t.x, t.y); // Draw new terrain
        else if (t.type === 'ice_patch') sprites.drawIcePatch(ctx, t.x, t.y); // Draw new terrain
        else if (t.type === 'large_rock') sprites.drawLargeRock(ctx, t.x, t.y); // Draw new terrain
        else if (t.type === 'dunes') sprites.drawDunes(ctx, t.x, t.y, globalAnimTimer); // Draw new terrain
        else if (t.type === 'palm_tree') sprites.drawPalmTree(ctx, t.x, t.y); // Draw new terrain
        else if (t.type === 'coral_formation') sprites.drawCoralFormation(ctx, t.x, t.y); // Draw new terrain
      });
      shards.forEach(s => {
        ctx.fillStyle = '#67E8F9';
        ctx.beginPath();
        ctx.arc(s.x, s.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
      materialDrops.forEach(d => sprites.drawMaterial(ctx, d.x, d.y, d.type));
      enemyProjectiles.forEach(p => {
        const alpha = Math.min(1, p.lifespan / 0.5);
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Math.atan2(p.vy, p.vx));
        ctx.fillStyle = `rgba(163, 230, 53, ${alpha})`;
        ctx.fillRect(-7, -2, 14, 4);
        ctx.restore();
      });
      enemies.forEach(e => {
        if (e.type === 'charger') {
          sprites.drawCharger(ctx, e.x, e.y);
          if (e.state === 'charging') {
            const prog = e.chargeTimer / e.chargeTime;
            ctx.fillStyle = `rgba(220, 38, 38, 0.3)`;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.attackRadius * prog, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = `rgba(239, 68, 68, 0.7)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.attackRadius, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else if (e.type === 'spitter') {
          sprites.drawSpitter(ctx, e.x, e.y);
        } else if (e.type === 'worm') {
          sprites.drawWorm(ctx, e.x, e.y, globalAnimTimer);
        } else if (e.type === 'squid') {
          sprites.drawSquid(ctx, e.x, e.y, globalAnimTimer);
        } // Draw squid
        else if (e.type === 'ice_crawler') {
          sprites.drawIceCrawler(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien
        else if (e.type === 'frost_beetle') {
          sprites.drawFrostBeetle(ctx, e.x, e.y);
        } // Draw new alien
        else if (e.type === 'snow_serpent') {
          sprites.drawSnowSerpent(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien
        else if (e.type === 'sand_beast') {
          sprites.drawSandBeast(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien
        else if (e.type === 'scorpion_drone') {
          sprites.drawScorpionDrone(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien
        else if (e.type === 'heat_worm') {
          sprites.drawHeatWorm(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien
        else if (e.type === 'crab_mutant') {
          sprites.drawCrabMutant(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien
        else if (e.type === 'jellyfish') {
          sprites.drawJellyfish(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien
        else if (e.type === 'piranha_swarm') {
          sprites.drawPiranha(ctx, e.x, e.y, globalAnimTimer);
        } // Draw new alien swarm (uses single piranha sprite for simplicity)

        const hp = e.health / e.maxHealth;
        if (e.health > 0 && hp < 1) {
          ctx.fillStyle = '#4B5563';
          ctx.fillRect(e.x - e.size, e.y - e.size - 5, e.size * 2, 4);
          ctx.fillStyle = '#F87171';
          ctx.fillRect(e.x - e.size, e.y - e.size - 5, e.size * 2 * hp, 4);
        }
      });
      playerProjectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      });
      if (rover.active) sprites.drawRover(ctx, rover.x, rover.y);
      drones.forEach(d => sprites.drawDrone(ctx, d.x, d.y));

      missiles.forEach(m => sprites.drawMissile(ctx, m.x, m.y, m.angle));

      particles.forEach(p => {
        const alpha = p.lifetime / 0.8;
        ctx.fillStyle = p.color.replace(/, [0-9.]+\)/, `, ${alpha})`);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });

      if (orbitalStrike.target) {
        const radius = orbitalStrike.explosionRadius * (1 - (orbitalStrike.impactTimer / 1.5));
        ctx.strokeStyle = `rgba(255, 100, 100, 0.8)`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(orbitalStrike.target.x, orbitalStrike.target.y, radius, 0, Math.PI * 2);
        ctx.stroke();
      }

      sprites.drawPlayer(ctx, player.x, player.y, player.animFrame, mouse.facingRight);
      drawHUD();
    }

    function gameLoop(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000 || 0;
      lastTime = currentTime;
      globalAnimTimer += deltaTime;
      if (player.animTimer !== undefined) player.animTimer += deltaTime;

      const autoShootToggle = document.getElementById('autoShootToggle');
      const abortMissionButton = document.getElementById('abortMissionButton');
      if (gameState === 'playing' || gameState === 'paused') {
        autoShootToggle.style.display = 'block';
        // Simplified text for auto-shoot button
        autoShootToggle.textContent = player.autoShoot ? 'Auto-Shoot: ON' : 'Auto-Shoot: OFF';
        abortMissionButton.style.display = 'block';
      } else {
        autoShootToggle.style.display = 'none';
        abortMissionButton.style.display = 'none';
      }

      if (gameState === 'starbase_hub' || gameState === 'station_menu') {
        updateHub(deltaTime);
      } else if (gameState === 'playing') {
        updatePlaying(deltaTime);
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (gameState === 'starbase_hub' || gameState === 'station_menu') {
        drawHub();
      } else if (gameState === 'playing' || gameState === 'paused') {
        drawPlaying();
      }

      if (gameState === 'gameOver') {
        drawPlaying();
        showOverlay('gameOver');
        player.level = Math.max(1, player.level - 1);
        player.xp = 0;
        player.xpToNextLevel = Math.floor(100 * Math.pow(1.5, player.level - 1));
        player.health = player.maxHealth;
        player.stamina = player.maxStamina;
        applyPermanentUpgrades();
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        return;
      } else if (gameState === 'victory') {
        drawPlaying();
        showOverlay('victory');
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        return;
      }

      gameLoopId = requestAnimationFrame(gameLoop);
    }

    function init() {
      const genericButton = `onclick="window.returnToHub()" class="game-button"`;
      const overlays = {
        gameOver: `<h1 class="text-5xl mb-4 text-red-500">Mission Failed</h1><p class="text-lg mb-12 text-gray-300">You have been overrun.<br>Level lost. Try again!</p><button ${genericButton}>Return to Hangar</button>`,
        victory: `<h1 class="text-5xl mb-4 text-green-400">Mission Accomplished</h1><p class="text-lg mb-12 text-gray-300">Welcome back, survivor.</p><button ${genericButton}>Return to Hangar</button>`
      };
      for (const [id, content] of Object.entries(overlays)) {
        document.getElementById(id).innerHTML = content;
      }

      window.addEventListener('resize', setCanvasDimensions);
      window.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();
        if (keys.hasOwnProperty(key)) keys[key] = true;
        if (key === 'e' && (gameState === 'starbase_hub' || gameState === 'station_menu') && interactionTarget) {
          handleInteraction(interactionTarget.id);
        }
        // Only allow abort if not in a menu or map selection
        if ((key === 'x' || key === 'escape') && (gameState === 'playing' || gameState === 'paused')) {
          window.returnToHub();
        }
      });
      window.addEventListener('keyup', e => {
        if (keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false;
      });
      canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
        mouse.facingRight = mouse.x > player.x;
      });
      canvas.addEventListener('mousedown', e => {
        if (e.button === 0) mouse.click = true;
      });
      canvas.addEventListener('mouseup', e => {
        if (e.button === 0) mouse.click = false;
      });

      document.getElementById('autoShootToggle').addEventListener('click', () => {
        player.autoShoot = !player.autoShoot;
      });
      document.getElementById('abortMissionButton').addEventListener('click', () => {
        window.returnToHub();
      });

      setupPlayer();
      setCanvasDimensions();
      createTextures();
      updateMaterialHUD();
      returnToHub();
    }

    init();

    function mouseLoop() {
      if ((mouse.click || player.autoShoot) && gameState === 'playing' && player.fireCooldown <= 0) {
        fireProjectile();
      }
      requestAnimationFrame(mouseLoop);
    }

    mouseLoop();
  })();
</script>
</body>
</html>
